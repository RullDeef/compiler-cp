// Code generated from GoParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // GoParser

import (
	"fmt"
	"strconv"
  	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}


type GoParser struct {
	*antlr.BaseParser
}

var GoParserParserStaticData struct {
  once                   sync.Once
  serializedATN          []int32
  LiteralNames           []string
  SymbolicNames          []string
  RuleNames              []string
  PredictionContextCache *antlr.PredictionContextCache
  atn                    *antlr.ATN
  decisionToDFA          []*antlr.DFA
}

func goparserParserInit() {
  staticData := &GoParserParserStaticData
  staticData.LiteralNames = []string{
    "", "'break'", "'default'", "'func'", "'interface'", "'select'", "'case'", 
    "'defer'", "'go'", "'map'", "'struct'", "'chan'", "'else'", "'goto'", 
    "'package'", "'switch'", "'const'", "'fallthrough'", "'if'", "'range'", 
    "'type'", "'continue'", "'for'", "'import'", "'return'", "'var'", "'nil'", 
    "'true'", "'false'", "", "'('", "')'", "'{'", "'}'", "'['", "']'", "'='", 
    "','", "';'", "':'", "'.'", "'++'", "'--'", "':='", "'...'", "'||'", 
    "'&&'", "'=='", "'!='", "'<'", "'<='", "'>'", "'>='", "'|'", "'/'", 
    "'%'", "'<<'", "'>>'", "'&^'", "'~'", "'!'", "'+'", "'-'", "'^'", "'*'", 
    "'&'", "'<-'",
  }
  staticData.SymbolicNames = []string{
    "", "BREAK", "DEFAULT", "FUNC", "INTERFACE", "SELECT", "CASE", "DEFER", 
    "GO", "MAP", "STRUCT", "CHAN", "ELSE", "GOTO", "PACKAGE", "SWITCH", 
    "CONST", "FALLTHROUGH", "IF", "RANGE", "TYPE", "CONTINUE", "FOR", "IMPORT", 
    "RETURN", "VAR", "NIL_LIT", "TRUE_LIT", "FALSE_LIT", "IDENTIFIER", "L_PAREN", 
    "R_PAREN", "L_CURLY", "R_CURLY", "L_BRACKET", "R_BRACKET", "ASSIGN", 
    "COMMA", "SEMI", "COLON", "DOT", "PLUS_PLUS", "MINUS_MINUS", "DECLARE_ASSIGN", 
    "ELLIPSIS", "LOGICAL_OR", "LOGICAL_AND", "EQUALS", "NOT_EQUALS", "LESS", 
    "LESS_OR_EQUALS", "GREATER", "GREATER_OR_EQUALS", "OR", "DIV", "MOD", 
    "LSHIFT", "RSHIFT", "BIT_CLEAR", "UNDERLYING", "EXCLAMATION", "PLUS", 
    "MINUS", "CARET", "STAR", "AMPERSAND", "RECEIVE", "DECIMAL_LIT", "BINARY_LIT", 
    "OCTAL_LIT", "HEX_LIT", "FLOAT_LIT", "DECIMAL_FLOAT_LIT", "HEX_FLOAT_LIT", 
    "IMAGINARY_LIT", "RUNE_LIT", "BYTE_VALUE", "OCTAL_BYTE_VALUE", "HEX_BYTE_VALUE", 
    "LITTLE_U_VALUE", "BIG_U_VALUE", "RAW_STRING_LIT", "INTERPRETED_STRING_LIT", 
    "WS", "COMMENT", "TERMINATOR", "LINE_COMMENT", "WS_NLSEMI", "COMMENT_NLSEMI", 
    "LINE_COMMENT_NLSEMI", "EOS", "OTHER",
  }
  staticData.RuleNames = []string{
    "sourceFile", "packageClause", "importDecl", "importSpec", "importPath", 
    "declaration", "constDecl", "constSpec", "identifierList", "expressionList", 
    "typeDecl", "typeSpec", "aliasDecl", "typeDef", "typeParameters", "typeParameterDecl", 
    "typeElement", "typeTerm", "functionDecl", "methodDecl", "receiver", 
    "varDecl", "varSpec", "block", "statementList", "statement", "simpleStmt", 
    "expressionStmt", "sendStmt", "incDecStmt", "assignment", "assign_op", 
    "shortVarDecl", "labeledStmt", "returnStmt", "breakStmt", "continueStmt", 
    "gotoStmt", "fallthroughStmt", "deferStmt", "ifStmt", "switchStmt", 
    "exprSwitchStmt", "exprCaseClause", "exprSwitchCase", "typeSwitchStmt", 
    "typeSwitchGuard", "typeCaseClause", "typeSwitchCase", "typeList", "selectStmt", 
    "commClause", "commCase", "recvStmt", "forStmt", "forClause", "rangeClause", 
    "goStmt", "type_", "typeArgs", "typeName", "typeLit", "arrayType", "arrayLength", 
    "elementType", "pointerType", "interfaceType", "sliceType", "mapType", 
    "channelType", "methodSpec", "functionType", "signature", "result", 
    "parameters", "parameterDecl", "expression", "primaryExpr", "conversion", 
    "operand", "literal", "basicLit", "integer", "operandName", "qualifiedIdent", 
    "compositeLit", "literalType", "literalValue", "elementList", "keyedElement", 
    "key", "element", "structType", "fieldDecl", "string_", "embeddedField", 
    "functionLit", "index", "slice_", "typeAssertion", "arguments", "methodExpr", 
    "eos",
  }
  staticData.PredictionContextCache = antlr.NewPredictionContextCache()
  staticData.serializedATN = []int32{
	4, 1, 91, 1007, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 
	4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 
	10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 
	2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2, 
	21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 
	7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 
	31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 
	2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 
	42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47, 
	7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7, 
	52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 
	2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2, 
	63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68, 
	7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7, 
	73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78, 
	2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2, 
	84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89, 
	7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7, 
	94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 99, 
	2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 1, 0, 1, 0, 1, 0, 1, 0, 
	1, 0, 5, 0, 212, 8, 0, 10, 0, 12, 0, 215, 9, 0, 1, 0, 1, 0, 1, 0, 3, 0, 
	220, 8, 0, 1, 0, 1, 0, 5, 0, 224, 8, 0, 10, 0, 12, 0, 227, 9, 0, 1, 0, 
	1, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 5, 2, 240, 
	8, 2, 10, 2, 12, 2, 243, 9, 2, 1, 2, 3, 2, 246, 8, 2, 1, 3, 3, 3, 249, 
	8, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 3, 5, 258, 8, 5, 1, 6, 
	1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 5, 6, 266, 8, 6, 10, 6, 12, 6, 269, 9, 6, 
	1, 6, 3, 6, 272, 8, 6, 1, 7, 1, 7, 3, 7, 276, 8, 7, 1, 7, 1, 7, 3, 7, 280, 
	8, 7, 1, 8, 1, 8, 1, 8, 5, 8, 285, 8, 8, 10, 8, 12, 8, 288, 9, 8, 1, 9, 
	1, 9, 1, 9, 5, 9, 293, 8, 9, 10, 9, 12, 9, 296, 9, 9, 1, 10, 1, 10, 1, 
	10, 1, 10, 1, 10, 1, 10, 5, 10, 304, 8, 10, 10, 10, 12, 10, 307, 9, 10, 
	1, 10, 3, 10, 310, 8, 10, 1, 11, 1, 11, 3, 11, 314, 8, 11, 1, 12, 1, 12, 
	1, 12, 1, 12, 1, 13, 1, 13, 3, 13, 322, 8, 13, 1, 13, 1, 13, 1, 14, 1, 
	14, 1, 14, 1, 14, 5, 14, 330, 8, 14, 10, 14, 12, 14, 333, 9, 14, 1, 14, 
	1, 14, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 5, 16, 343, 8, 16, 10, 
	16, 12, 16, 346, 9, 16, 1, 17, 3, 17, 349, 8, 17, 1, 17, 1, 17, 1, 18, 
	1, 18, 1, 18, 3, 18, 356, 8, 18, 1, 18, 1, 18, 3, 18, 360, 8, 18, 1, 19, 
	1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 367, 8, 19, 1, 20, 1, 20, 1, 21, 1, 
	21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 377, 8, 21, 10, 21, 12, 21, 380, 
	9, 21, 1, 21, 3, 21, 383, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 389, 
	8, 22, 1, 22, 1, 22, 3, 22, 393, 8, 22, 1, 23, 1, 23, 3, 23, 397, 8, 23, 
	1, 23, 1, 23, 1, 24, 3, 24, 402, 8, 24, 1, 24, 3, 24, 405, 8, 24, 3, 24, 
	407, 8, 24, 1, 24, 1, 24, 1, 24, 4, 24, 412, 8, 24, 11, 24, 12, 24, 413, 
	1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 
	25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 431, 8, 25, 1, 26, 1, 26, 1, 26, 
	1, 26, 1, 26, 3, 26, 438, 8, 26, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 
	28, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 31, 3, 31, 454, 
	8, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 3, 
	33, 465, 8, 33, 1, 34, 1, 34, 3, 34, 469, 8, 34, 1, 35, 1, 35, 3, 35, 473, 
	8, 35, 1, 36, 1, 36, 3, 36, 477, 8, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1, 
	38, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 
	1, 40, 1, 40, 3, 40, 496, 8, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 502, 
	8, 40, 3, 40, 504, 8, 40, 1, 41, 1, 41, 3, 41, 508, 8, 41, 1, 42, 1, 42, 
	3, 42, 512, 8, 42, 1, 42, 3, 42, 515, 8, 42, 1, 42, 1, 42, 3, 42, 519, 
	8, 42, 3, 42, 521, 8, 42, 1, 42, 1, 42, 5, 42, 525, 8, 42, 10, 42, 12, 
	42, 528, 9, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 3, 43, 535, 8, 43, 1, 
	44, 1, 44, 1, 44, 3, 44, 540, 8, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 
	1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 551, 8, 45, 1, 45, 1, 45, 5, 45, 555, 
	8, 45, 10, 45, 12, 45, 558, 9, 45, 1, 45, 1, 45, 1, 46, 1, 46, 3, 46, 564, 
	8, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 3, 
	47, 575, 8, 47, 1, 48, 1, 48, 1, 48, 3, 48, 580, 8, 48, 1, 49, 1, 49, 3, 
	49, 584, 8, 49, 1, 49, 1, 49, 1, 49, 3, 49, 589, 8, 49, 5, 49, 591, 8, 
	49, 10, 49, 12, 49, 594, 9, 49, 1, 50, 1, 50, 1, 50, 5, 50, 599, 8, 50, 
	10, 50, 12, 50, 602, 9, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 3, 51, 609, 
	8, 51, 1, 52, 1, 52, 1, 52, 3, 52, 614, 8, 52, 1, 52, 3, 52, 617, 8, 52, 
	1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 625, 8, 53, 1, 53, 1, 
	53, 1, 54, 1, 54, 3, 54, 631, 8, 54, 1, 54, 1, 54, 3, 54, 635, 8, 54, 3, 
	54, 637, 8, 54, 1, 54, 1, 54, 1, 55, 3, 55, 642, 8, 55, 1, 55, 1, 55, 3, 
	55, 646, 8, 55, 1, 55, 1, 55, 3, 55, 650, 8, 55, 1, 56, 1, 56, 1, 56, 1, 
	56, 1, 56, 1, 56, 3, 56, 658, 8, 56, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 
	1, 57, 1, 58, 1, 58, 3, 58, 668, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 
	58, 3, 58, 675, 8, 58, 1, 59, 1, 59, 1, 59, 3, 59, 680, 8, 59, 1, 59, 1, 
	59, 1, 60, 1, 60, 3, 60, 686, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 
	1, 61, 1, 61, 1, 61, 3, 61, 696, 8, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 
	62, 1, 63, 1, 63, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 
	1, 66, 3, 66, 714, 8, 66, 1, 66, 1, 66, 5, 66, 718, 8, 66, 10, 66, 12, 
	66, 721, 9, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 
	1, 68, 1, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 740, 
	8, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 750, 
	8, 70, 1, 71, 1, 71, 1, 71, 1, 72, 1, 72, 3, 72, 757, 8, 72, 1, 73, 1, 
	73, 3, 73, 761, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 5, 74, 767, 8, 74, 10, 
	74, 12, 74, 770, 9, 74, 1, 74, 3, 74, 773, 8, 74, 3, 74, 775, 8, 74, 1, 
	74, 1, 74, 1, 75, 3, 75, 780, 8, 75, 1, 75, 3, 75, 783, 8, 75, 1, 75, 1, 
	75, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 791, 8, 76, 1, 76, 1, 76, 1, 76, 
	1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 
	76, 1, 76, 5, 76, 808, 8, 76, 10, 76, 12, 76, 811, 9, 76, 1, 77, 1, 77, 
	1, 77, 1, 77, 3, 77, 817, 8, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 
	77, 1, 77, 3, 77, 826, 8, 77, 5, 77, 828, 8, 77, 10, 77, 12, 77, 831, 9, 
	77, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 837, 8, 78, 1, 78, 1, 78, 1, 79, 
	1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 847, 8, 79, 1, 80, 1, 80, 1, 
	80, 3, 80, 852, 8, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 
	860, 8, 81, 1, 82, 1, 82, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 
	85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 
	1, 86, 1, 86, 3, 86, 883, 8, 86, 3, 86, 885, 8, 86, 1, 87, 1, 87, 1, 87, 
	3, 87, 890, 8, 87, 3, 87, 892, 8, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 
	5, 88, 899, 8, 88, 10, 88, 12, 88, 902, 9, 88, 1, 89, 1, 89, 1, 89, 3, 
	89, 907, 8, 89, 1, 89, 1, 89, 1, 90, 1, 90, 3, 90, 913, 8, 90, 1, 91, 1, 
	91, 3, 91, 917, 8, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 5, 92, 924, 8, 
	92, 10, 92, 12, 92, 927, 9, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 
	3, 93, 935, 8, 93, 1, 93, 3, 93, 938, 8, 93, 1, 94, 1, 94, 1, 95, 3, 95, 
	943, 8, 95, 1, 95, 1, 95, 3, 95, 947, 8, 95, 1, 96, 1, 96, 1, 96, 1, 96, 
	1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 3, 98, 959, 8, 98, 1, 98, 1, 
	98, 3, 98, 963, 8, 98, 1, 98, 3, 98, 966, 8, 98, 1, 98, 1, 98, 1, 98, 1, 
	98, 1, 98, 3, 98, 973, 8, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 
	1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 987, 8, 100, 3, 
	100, 989, 8, 100, 1, 100, 3, 100, 992, 8, 100, 1, 100, 3, 100, 995, 8, 
	100, 3, 100, 997, 8, 100, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 
	1, 102, 1, 102, 1, 102, 0, 2, 152, 154, 103, 0, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 
	52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 
	88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 
	120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 
	150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 
	180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 0, 10, 
	2, 0, 29, 29, 40, 40, 1, 0, 41, 42, 2, 0, 53, 58, 61, 65, 1, 0, 60, 66, 
	2, 0, 54, 58, 64, 65, 2, 0, 53, 53, 61, 63, 1, 0, 47, 52, 2, 0, 67, 70, 
	74, 75, 1, 0, 81, 82, 2, 1, 38, 38, 90, 90, 1069, 0, 206, 1, 0, 0, 0, 2, 
	230, 1, 0, 0, 0, 4, 233, 1, 0, 0, 0, 6, 248, 1, 0, 0, 0, 8, 252, 1, 0, 
	0, 0, 10, 257, 1, 0, 0, 0, 12, 259, 1, 0, 0, 0, 14, 273, 1, 0, 0, 0, 16, 
	281, 1, 0, 0, 0, 18, 289, 1, 0, 0, 0, 20, 297, 1, 0, 0, 0, 22, 313, 1, 
	0, 0, 0, 24, 315, 1, 0, 0, 0, 26, 319, 1, 0, 0, 0, 28, 325, 1, 0, 0, 0, 
	30, 336, 1, 0, 0, 0, 32, 339, 1, 0, 0, 0, 34, 348, 1, 0, 0, 0, 36, 352, 
	1, 0, 0, 0, 38, 361, 1, 0, 0, 0, 40, 368, 1, 0, 0, 0, 42, 370, 1, 0, 0, 
	0, 44, 384, 1, 0, 0, 0, 46, 394, 1, 0, 0, 0, 48, 411, 1, 0, 0, 0, 50, 430, 
	1, 0, 0, 0, 52, 437, 1, 0, 0, 0, 54, 439, 1, 0, 0, 0, 56, 441, 1, 0, 0, 
	0, 58, 445, 1, 0, 0, 0, 60, 448, 1, 0, 0, 0, 62, 453, 1, 0, 0, 0, 64, 457, 
	1, 0, 0, 0, 66, 461, 1, 0, 0, 0, 68, 466, 1, 0, 0, 0, 70, 470, 1, 0, 0, 
	0, 72, 474, 1, 0, 0, 0, 74, 478, 1, 0, 0, 0, 76, 481, 1, 0, 0, 0, 78, 483, 
	1, 0, 0, 0, 80, 486, 1, 0, 0, 0, 82, 507, 1, 0, 0, 0, 84, 509, 1, 0, 0, 
	0, 86, 531, 1, 0, 0, 0, 88, 539, 1, 0, 0, 0, 90, 541, 1, 0, 0, 0, 92, 563, 
	1, 0, 0, 0, 94, 571, 1, 0, 0, 0, 96, 579, 1, 0, 0, 0, 98, 583, 1, 0, 0, 
	0, 100, 595, 1, 0, 0, 0, 102, 605, 1, 0, 0, 0, 104, 616, 1, 0, 0, 0, 106, 
	624, 1, 0, 0, 0, 108, 628, 1, 0, 0, 0, 110, 641, 1, 0, 0, 0, 112, 657, 
	1, 0, 0, 0, 114, 662, 1, 0, 0, 0, 116, 674, 1, 0, 0, 0, 118, 676, 1, 0, 
	0, 0, 120, 685, 1, 0, 0, 0, 122, 695, 1, 0, 0, 0, 124, 697, 1, 0, 0, 0, 
	126, 702, 1, 0, 0, 0, 128, 704, 1, 0, 0, 0, 130, 706, 1, 0, 0, 0, 132, 
	709, 1, 0, 0, 0, 134, 724, 1, 0, 0, 0, 136, 728, 1, 0, 0, 0, 138, 739, 
	1, 0, 0, 0, 140, 749, 1, 0, 0, 0, 142, 751, 1, 0, 0, 0, 144, 754, 1, 0, 
	0, 0, 146, 760, 1, 0, 0, 0, 148, 762, 1, 0, 0, 0, 150, 779, 1, 0, 0, 0, 
	152, 790, 1, 0, 0, 0, 154, 816, 1, 0, 0, 0, 156, 832, 1, 0, 0, 0, 158, 
	846, 1, 0, 0, 0, 160, 851, 1, 0, 0, 0, 162, 859, 1, 0, 0, 0, 164, 861, 
	1, 0, 0, 0, 166, 863, 1, 0, 0, 0, 168, 865, 1, 0, 0, 0, 170, 869, 1, 0, 
	0, 0, 172, 884, 1, 0, 0, 0, 174, 886, 1, 0, 0, 0, 176, 895, 1, 0, 0, 0, 
	178, 906, 1, 0, 0, 0, 180, 912, 1, 0, 0, 0, 182, 916, 1, 0, 0, 0, 184, 
	918, 1, 0, 0, 0, 186, 934, 1, 0, 0, 0, 188, 939, 1, 0, 0, 0, 190, 942, 
	1, 0, 0, 0, 192, 948, 1, 0, 0, 0, 194, 952, 1, 0, 0, 0, 196, 956, 1, 0, 
	0, 0, 198, 976, 1, 0, 0, 0, 200, 981, 1, 0, 0, 0, 202, 1000, 1, 0, 0, 0, 
	204, 1004, 1, 0, 0, 0, 206, 207, 3, 2, 1, 0, 207, 213, 3, 204, 102, 0, 
	208, 209, 3, 4, 2, 0, 209, 210, 3, 204, 102, 0, 210, 212, 1, 0, 0, 0, 211, 
	208, 1, 0, 0, 0, 212, 215, 1, 0, 0, 0, 213, 211, 1, 0, 0, 0, 213, 214, 
	1, 0, 0, 0, 214, 225, 1, 0, 0, 0, 215, 213, 1, 0, 0, 0, 216, 220, 3, 36, 
	18, 0, 217, 220, 3, 38, 19, 0, 218, 220, 3, 10, 5, 0, 219, 216, 1, 0, 0, 
	0, 219, 217, 1, 0, 0, 0, 219, 218, 1, 0, 0, 0, 220, 221, 1, 0, 0, 0, 221, 
	222, 3, 204, 102, 0, 222, 224, 1, 0, 0, 0, 223, 219, 1, 0, 0, 0, 224, 227, 
	1, 0, 0, 0, 225, 223, 1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 228, 1, 0, 
	0, 0, 227, 225, 1, 0, 0, 0, 228, 229, 5, 0, 0, 1, 229, 1, 1, 0, 0, 0, 230, 
	231, 5, 14, 0, 0, 231, 232, 5, 29, 0, 0, 232, 3, 1, 0, 0, 0, 233, 245, 
	5, 23, 0, 0, 234, 246, 3, 6, 3, 0, 235, 241, 5, 30, 0, 0, 236, 237, 3, 
	6, 3, 0, 237, 238, 3, 204, 102, 0, 238, 240, 1, 0, 0, 0, 239, 236, 1, 0, 
	0, 0, 240, 243, 1, 0, 0, 0, 241, 239, 1, 0, 0, 0, 241, 242, 1, 0, 0, 0, 
	242, 244, 1, 0, 0, 0, 243, 241, 1, 0, 0, 0, 244, 246, 5, 31, 0, 0, 245, 
	234, 1, 0, 0, 0, 245, 235, 1, 0, 0, 0, 246, 5, 1, 0, 0, 0, 247, 249, 7, 
	0, 0, 0, 248, 247, 1, 0, 0, 0, 248, 249, 1, 0, 0, 0, 249, 250, 1, 0, 0, 
	0, 250, 251, 3, 8, 4, 0, 251, 7, 1, 0, 0, 0, 252, 253, 3, 188, 94, 0, 253, 
	9, 1, 0, 0, 0, 254, 258, 3, 12, 6, 0, 255, 258, 3, 20, 10, 0, 256, 258, 
	3, 42, 21, 0, 257, 254, 1, 0, 0, 0, 257, 255, 1, 0, 0, 0, 257, 256, 1, 
	0, 0, 0, 258, 11, 1, 0, 0, 0, 259, 271, 5, 16, 0, 0, 260, 272, 3, 14, 7, 
	0, 261, 267, 5, 30, 0, 0, 262, 263, 3, 14, 7, 0, 263, 264, 3, 204, 102, 
	0, 264, 266, 1, 0, 0, 0, 265, 262, 1, 0, 0, 0, 266, 269, 1, 0, 0, 0, 267, 
	265, 1, 0, 0, 0, 267, 268, 1, 0, 0, 0, 268, 270, 1, 0, 0, 0, 269, 267, 
	1, 0, 0, 0, 270, 272, 5, 31, 0, 0, 271, 260, 1, 0, 0, 0, 271, 261, 1, 0, 
	0, 0, 272, 13, 1, 0, 0, 0, 273, 279, 3, 16, 8, 0, 274, 276, 3, 116, 58, 
	0, 275, 274, 1, 0, 0, 0, 275, 276, 1, 0, 0, 0, 276, 277, 1, 0, 0, 0, 277, 
	278, 5, 36, 0, 0, 278, 280, 3, 18, 9, 0, 279, 275, 1, 0, 0, 0, 279, 280, 
	1, 0, 0, 0, 280, 15, 1, 0, 0, 0, 281, 286, 5, 29, 0, 0, 282, 283, 5, 37, 
	0, 0, 283, 285, 5, 29, 0, 0, 284, 282, 1, 0, 0, 0, 285, 288, 1, 0, 0, 0, 
	286, 284, 1, 0, 0, 0, 286, 287, 1, 0, 0, 0, 287, 17, 1, 0, 0, 0, 288, 286, 
	1, 0, 0, 0, 289, 294, 3, 152, 76, 0, 290, 291, 5, 37, 0, 0, 291, 293, 3, 
	152, 76, 0, 292, 290, 1, 0, 0, 0, 293, 296, 1, 0, 0, 0, 294, 292, 1, 0, 
	0, 0, 294, 295, 1, 0, 0, 0, 295, 19, 1, 0, 0, 0, 296, 294, 1, 0, 0, 0, 
	297, 309, 5, 20, 0, 0, 298, 310, 3, 22, 11, 0, 299, 305, 5, 30, 0, 0, 300, 
	301, 3, 22, 11, 0, 301, 302, 3, 204, 102, 0, 302, 304, 1, 0, 0, 0, 303, 
	300, 1, 0, 0, 0, 304, 307, 1, 0, 0, 0, 305, 303, 1, 0, 0, 0, 305, 306, 
	1, 0, 0, 0, 306, 308, 1, 0, 0, 0, 307, 305, 1, 0, 0, 0, 308, 310, 5, 31, 
	0, 0, 309, 298, 1, 0, 0, 0, 309, 299, 1, 0, 0, 0, 310, 21, 1, 0, 0, 0, 
	311, 314, 3, 24, 12, 0, 312, 314, 3, 26, 13, 0, 313, 311, 1, 0, 0, 0, 313, 
	312, 1, 0, 0, 0, 314, 23, 1, 0, 0, 0, 315, 316, 5, 29, 0, 0, 316, 317, 
	5, 36, 0, 0, 317, 318, 3, 116, 58, 0, 318, 25, 1, 0, 0, 0, 319, 321, 5, 
	29, 0, 0, 320, 322, 3, 28, 14, 0, 321, 320, 1, 0, 0, 0, 321, 322, 1, 0, 
	0, 0, 322, 323, 1, 0, 0, 0, 323, 324, 3, 116, 58, 0, 324, 27, 1, 0, 0, 
	0, 325, 326, 5, 34, 0, 0, 326, 331, 3, 30, 15, 0, 327, 328, 5, 37, 0, 0, 
	328, 330, 3, 30, 15, 0, 329, 327, 1, 0, 0, 0, 330, 333, 1, 0, 0, 0, 331, 
	329, 1, 0, 0, 0, 331, 332, 1, 0, 0, 0, 332, 334, 1, 0, 0, 0, 333, 331, 
	1, 0, 0, 0, 334, 335, 5, 35, 0, 0, 335, 29, 1, 0, 0, 0, 336, 337, 3, 16, 
	8, 0, 337, 338, 3, 32, 16, 0, 338, 31, 1, 0, 0, 0, 339, 344, 3, 34, 17, 
	0, 340, 341, 5, 53, 0, 0, 341, 343, 3, 34, 17, 0, 342, 340, 1, 0, 0, 0, 
	343, 346, 1, 0, 0, 0, 344, 342, 1, 0, 0, 0, 344, 345, 1, 0, 0, 0, 345, 
	33, 1, 0, 0, 0, 346, 344, 1, 0, 0, 0, 347, 349, 5, 59, 0, 0, 348, 347, 
	1, 0, 0, 0, 348, 349, 1, 0, 0, 0, 349, 350, 1, 0, 0, 0, 350, 351, 3, 116, 
	58, 0, 351, 35, 1, 0, 0, 0, 352, 353, 5, 3, 0, 0, 353, 355, 5, 29, 0, 0, 
	354, 356, 3, 28, 14, 0, 355, 354, 1, 0, 0, 0, 355, 356, 1, 0, 0, 0, 356, 
	357, 1, 0, 0, 0, 357, 359, 3, 144, 72, 0, 358, 360, 3, 46, 23, 0, 359, 
	358, 1, 0, 0, 0, 359, 360, 1, 0, 0, 0, 360, 37, 1, 0, 0, 0, 361, 362, 5, 
	3, 0, 0, 362, 363, 3, 40, 20, 0, 363, 364, 5, 29, 0, 0, 364, 366, 3, 144, 
	72, 0, 365, 367, 3, 46, 23, 0, 366, 365, 1, 0, 0, 0, 366, 367, 1, 0, 0, 
	0, 367, 39, 1, 0, 0, 0, 368, 369, 3, 148, 74, 0, 369, 41, 1, 0, 0, 0, 370, 
	382, 5, 25, 0, 0, 371, 383, 3, 44, 22, 0, 372, 378, 5, 30, 0, 0, 373, 374, 
	3, 44, 22, 0, 374, 375, 3, 204, 102, 0, 375, 377, 1, 0, 0, 0, 376, 373, 
	1, 0, 0, 0, 377, 380, 1, 0, 0, 0, 378, 376, 1, 0, 0, 0, 378, 379, 1, 0, 
	0, 0, 379, 381, 1, 0, 0, 0, 380, 378, 1, 0, 0, 0, 381, 383, 5, 31, 0, 0, 
	382, 371, 1, 0, 0, 0, 382, 372, 1, 0, 0, 0, 383, 43, 1, 0, 0, 0, 384, 392, 
	3, 16, 8, 0, 385, 388, 3, 116, 58, 0, 386, 387, 5, 36, 0, 0, 387, 389, 
	3, 18, 9, 0, 388, 386, 1, 0, 0, 0, 388, 389, 1, 0, 0, 0, 389, 393, 1, 0, 
	0, 0, 390, 391, 5, 36, 0, 0, 391, 393, 3, 18, 9, 0, 392, 385, 1, 0, 0, 
	0, 392, 390, 1, 0, 0, 0, 393, 45, 1, 0, 0, 0, 394, 396, 5, 32, 0, 0, 395, 
	397, 3, 48, 24, 0, 396, 395, 1, 0, 0, 0, 396, 397, 1, 0, 0, 0, 397, 398, 
	1, 0, 0, 0, 398, 399, 5, 33, 0, 0, 399, 47, 1, 0, 0, 0, 400, 402, 5, 38, 
	0, 0, 401, 400, 1, 0, 0, 0, 401, 402, 1, 0, 0, 0, 402, 407, 1, 0, 0, 0, 
	403, 405, 5, 90, 0, 0, 404, 403, 1, 0, 0, 0, 404, 405, 1, 0, 0, 0, 405, 
	407, 1, 0, 0, 0, 406, 401, 1, 0, 0, 0, 406, 404, 1, 0, 0, 0, 407, 408, 
	1, 0, 0, 0, 408, 409, 3, 50, 25, 0, 409, 410, 3, 204, 102, 0, 410, 412, 
	1, 0, 0, 0, 411, 406, 1, 0, 0, 0, 412, 413, 1, 0, 0, 0, 413, 411, 1, 0, 
	0, 0, 413, 414, 1, 0, 0, 0, 414, 49, 1, 0, 0, 0, 415, 431, 3, 10, 5, 0, 
	416, 431, 3, 66, 33, 0, 417, 431, 3, 52, 26, 0, 418, 431, 3, 114, 57, 0, 
	419, 431, 3, 68, 34, 0, 420, 431, 3, 70, 35, 0, 421, 431, 3, 72, 36, 0, 
	422, 431, 3, 74, 37, 0, 423, 431, 3, 76, 38, 0, 424, 431, 3, 46, 23, 0, 
	425, 431, 3, 80, 40, 0, 426, 431, 3, 82, 41, 0, 427, 431, 3, 100, 50, 0, 
	428, 431, 3, 108, 54, 0, 429, 431, 3, 78, 39, 0, 430, 415, 1, 0, 0, 0, 
	430, 416, 1, 0, 0, 0, 430, 417, 1, 0, 0, 0, 430, 418, 1, 0, 0, 0, 430, 
	419, 1, 0, 0, 0, 430, 420, 1, 0, 0, 0, 430, 421, 1, 0, 0, 0, 430, 422, 
	1, 0, 0, 0, 430, 423, 1, 0, 0, 0, 430, 424, 1, 0, 0, 0, 430, 425, 1, 0, 
	0, 0, 430, 426, 1, 0, 0, 0, 430, 427, 1, 0, 0, 0, 430, 428, 1, 0, 0, 0, 
	430, 429, 1, 0, 0, 0, 431, 51, 1, 0, 0, 0, 432, 438, 3, 56, 28, 0, 433, 
	438, 3, 58, 29, 0, 434, 438, 3, 60, 30, 0, 435, 438, 3, 54, 27, 0, 436, 
	438, 3, 64, 32, 0, 437, 432, 1, 0, 0, 0, 437, 433, 1, 0, 0, 0, 437, 434, 
	1, 0, 0, 0, 437, 435, 1, 0, 0, 0, 437, 436, 1, 0, 0, 0, 438, 53, 1, 0, 
	0, 0, 439, 440, 3, 152, 76, 0, 440, 55, 1, 0, 0, 0, 441, 442, 3, 152, 76, 
	0, 442, 443, 5, 66, 0, 0, 443, 444, 3, 152, 76, 0, 444, 57, 1, 0, 0, 0, 
	445, 446, 3, 152, 76, 0, 446, 447, 7, 1, 0, 0, 447, 59, 1, 0, 0, 0, 448, 
	449, 3, 18, 9, 0, 449, 450, 3, 62, 31, 0, 450, 451, 3, 18, 9, 0, 451, 61, 
	1, 0, 0, 0, 452, 454, 7, 2, 0, 0, 453, 452, 1, 0, 0, 0, 453, 454, 1, 0, 
	0, 0, 454, 455, 1, 0, 0, 0, 455, 456, 5, 36, 0, 0, 456, 63, 1, 0, 0, 0, 
	457, 458, 3, 16, 8, 0, 458, 459, 5, 43, 0, 0, 459, 460, 3, 18, 9, 0, 460, 
	65, 1, 0, 0, 0, 461, 462, 5, 29, 0, 0, 462, 464, 5, 39, 0, 0, 463, 465, 
	3, 50, 25, 0, 464, 463, 1, 0, 0, 0, 464, 465, 1, 0, 0, 0, 465, 67, 1, 0, 
	0, 0, 466, 468, 5, 24, 0, 0, 467, 469, 3, 18, 9, 0, 468, 467, 1, 0, 0, 
	0, 468, 469, 1, 0, 0, 0, 469, 69, 1, 0, 0, 0, 470, 472, 5, 1, 0, 0, 471, 
	473, 5, 29, 0, 0, 472, 471, 1, 0, 0, 0, 472, 473, 1, 0, 0, 0, 473, 71, 
	1, 0, 0, 0, 474, 476, 5, 21, 0, 0, 475, 477, 5, 29, 0, 0, 476, 475, 1, 
	0, 0, 0, 476, 477, 1, 0, 0, 0, 477, 73, 1, 0, 0, 0, 478, 479, 5, 13, 0, 
	0, 479, 480, 5, 29, 0, 0, 480, 75, 1, 0, 0, 0, 481, 482, 5, 17, 0, 0, 482, 
	77, 1, 0, 0, 0, 483, 484, 5, 7, 0, 0, 484, 485, 3, 152, 76, 0, 485, 79, 
	1, 0, 0, 0, 486, 495, 5, 18, 0, 0, 487, 496, 3, 152, 76, 0, 488, 489, 3, 
	204, 102, 0, 489, 490, 3, 152, 76, 0, 490, 496, 1, 0, 0, 0, 491, 492, 3, 
	52, 26, 0, 492, 493, 3, 204, 102, 0, 493, 494, 3, 152, 76, 0, 494, 496, 
	1, 0, 0, 0, 495, 487, 1, 0, 0, 0, 495, 488, 1, 0, 0, 0, 495, 491, 1, 0, 
	0, 0, 496, 497, 1, 0, 0, 0, 497, 503, 3, 46, 23, 0, 498, 501, 5, 12, 0, 
	0, 499, 502, 3, 80, 40, 0, 500, 502, 3, 46, 23, 0, 501, 499, 1, 0, 0, 0, 
	501, 500, 1, 0, 0, 0, 502, 504, 1, 0, 0, 0, 503, 498, 1, 0, 0, 0, 503, 
	504, 1, 0, 0, 0, 504, 81, 1, 0, 0, 0, 505, 508, 3, 84, 42, 0, 506, 508, 
	3, 90, 45, 0, 507, 505, 1, 0, 0, 0, 507, 506, 1, 0, 0, 0, 508, 83, 1, 0, 
	0, 0, 509, 520, 5, 15, 0, 0, 510, 512, 3, 152, 76, 0, 511, 510, 1, 0, 0, 
	0, 511, 512, 1, 0, 0, 0, 512, 521, 1, 0, 0, 0, 513, 515, 3, 52, 26, 0, 
	514, 513, 1, 0, 0, 0, 514, 515, 1, 0, 0, 0, 515, 516, 1, 0, 0, 0, 516, 
	518, 3, 204, 102, 0, 517, 519, 3, 152, 76, 0, 518, 517, 1, 0, 0, 0, 518, 
	519, 1, 0, 0, 0, 519, 521, 1, 0, 0, 0, 520, 511, 1, 0, 0, 0, 520, 514, 
	1, 0, 0, 0, 521, 522, 1, 0, 0, 0, 522, 526, 5, 32, 0, 0, 523, 525, 3, 86, 
	43, 0, 524, 523, 1, 0, 0, 0, 525, 528, 1, 0, 0, 0, 526, 524, 1, 0, 0, 0, 
	526, 527, 1, 0, 0, 0, 527, 529, 1, 0, 0, 0, 528, 526, 1, 0, 0, 0, 529, 
	530, 5, 33, 0, 0, 530, 85, 1, 0, 0, 0, 531, 532, 3, 88, 44, 0, 532, 534, 
	5, 39, 0, 0, 533, 535, 3, 48, 24, 0, 534, 533, 1, 0, 0, 0, 534, 535, 1, 
	0, 0, 0, 535, 87, 1, 0, 0, 0, 536, 537, 5, 6, 0, 0, 537, 540, 3, 18, 9, 
	0, 538, 540, 5, 2, 0, 0, 539, 536, 1, 0, 0, 0, 539, 538, 1, 0, 0, 0, 540, 
	89, 1, 0, 0, 0, 541, 550, 5, 15, 0, 0, 542, 551, 3, 92, 46, 0, 543, 544, 
	3, 204, 102, 0, 544, 545, 3, 92, 46, 0, 545, 551, 1, 0, 0, 0, 546, 547, 
	3, 52, 26, 0, 547, 548, 3, 204, 102, 0, 548, 549, 3, 92, 46, 0, 549, 551, 
	1, 0, 0, 0, 550, 542, 1, 0, 0, 0, 550, 543, 1, 0, 0, 0, 550, 546, 1, 0, 
	0, 0, 551, 552, 1, 0, 0, 0, 552, 556, 5, 32, 0, 0, 553, 555, 3, 94, 47, 
	0, 554, 553, 1, 0, 0, 0, 555, 558, 1, 0, 0, 0, 556, 554, 1, 0, 0, 0, 556, 
	557, 1, 0, 0, 0, 557, 559, 1, 0, 0, 0, 558, 556, 1, 0, 0, 0, 559, 560, 
	5, 33, 0, 0, 560, 91, 1, 0, 0, 0, 561, 562, 5, 29, 0, 0, 562, 564, 5, 43, 
	0, 0, 563, 561, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0, 564, 565, 1, 0, 0, 0, 
	565, 566, 3, 154, 77, 0, 566, 567, 5, 40, 0, 0, 567, 568, 5, 30, 0, 0, 
	568, 569, 5, 20, 0, 0, 569, 570, 5, 31, 0, 0, 570, 93, 1, 0, 0, 0, 571, 
	572, 3, 96, 48, 0, 572, 574, 5, 39, 0, 0, 573, 575, 3, 48, 24, 0, 574, 
	573, 1, 0, 0, 0, 574, 575, 1, 0, 0, 0, 575, 95, 1, 0, 0, 0, 576, 577, 5, 
	6, 0, 0, 577, 580, 3, 98, 49, 0, 578, 580, 5, 2, 0, 0, 579, 576, 1, 0, 
	0, 0, 579, 578, 1, 0, 0, 0, 580, 97, 1, 0, 0, 0, 581, 584, 3, 116, 58, 
	0, 582, 584, 5, 26, 0, 0, 583, 581, 1, 0, 0, 0, 583, 582, 1, 0, 0, 0, 584, 
	592, 1, 0, 0, 0, 585, 588, 5, 37, 0, 0, 586, 589, 3, 116, 58, 0, 587, 589, 
	5, 26, 0, 0, 588, 586, 1, 0, 0, 0, 588, 587, 1, 0, 0, 0, 589, 591, 1, 0, 
	0, 0, 590, 585, 1, 0, 0, 0, 591, 594, 1, 0, 0, 0, 592, 590, 1, 0, 0, 0, 
	592, 593, 1, 0, 0, 0, 593, 99, 1, 0, 0, 0, 594, 592, 1, 0, 0, 0, 595, 596, 
	5, 5, 0, 0, 596, 600, 5, 32, 0, 0, 597, 599, 3, 102, 51, 0, 598, 597, 1, 
	0, 0, 0, 599, 602, 1, 0, 0, 0, 600, 598, 1, 0, 0, 0, 600, 601, 1, 0, 0, 
	0, 601, 603, 1, 0, 0, 0, 602, 600, 1, 0, 0, 0, 603, 604, 5, 33, 0, 0, 604, 
	101, 1, 0, 0, 0, 605, 606, 3, 104, 52, 0, 606, 608, 5, 39, 0, 0, 607, 609, 
	3, 48, 24, 0, 608, 607, 1, 0, 0, 0, 608, 609, 1, 0, 0, 0, 609, 103, 1, 
	0, 0, 0, 610, 613, 5, 6, 0, 0, 611, 614, 3, 56, 28, 0, 612, 614, 3, 106, 
	53, 0, 613, 611, 1, 0, 0, 0, 613, 612, 1, 0, 0, 0, 614, 617, 1, 0, 0, 0, 
	615, 617, 5, 2, 0, 0, 616, 610, 1, 0, 0, 0, 616, 615, 1, 0, 0, 0, 617, 
	105, 1, 0, 0, 0, 618, 619, 3, 18, 9, 0, 619, 620, 5, 36, 0, 0, 620, 625, 
	1, 0, 0, 0, 621, 622, 3, 16, 8, 0, 622, 623, 5, 43, 0, 0, 623, 625, 1, 
	0, 0, 0, 624, 618, 1, 0, 0, 0, 624, 621, 1, 0, 0, 0, 624, 625, 1, 0, 0, 
	0, 625, 626, 1, 0, 0, 0, 626, 627, 3, 152, 76, 0, 627, 107, 1, 0, 0, 0, 
	628, 636, 5, 22, 0, 0, 629, 631, 3, 152, 76, 0, 630, 629, 1, 0, 0, 0, 630, 
	631, 1, 0, 0, 0, 631, 637, 1, 0, 0, 0, 632, 637, 3, 110, 55, 0, 633, 635, 
	3, 112, 56, 0, 634, 633, 1, 0, 0, 0, 634, 635, 1, 0, 0, 0, 635, 637, 1, 
	0, 0, 0, 636, 630, 1, 0, 0, 0, 636, 632, 1, 0, 0, 0, 636, 634, 1, 0, 0, 
	0, 637, 638, 1, 0, 0, 0, 638, 639, 3, 46, 23, 0, 639, 109, 1, 0, 0, 0, 
	640, 642, 3, 52, 26, 0, 641, 640, 1, 0, 0, 0, 641, 642, 1, 0, 0, 0, 642, 
	643, 1, 0, 0, 0, 643, 645, 3, 204, 102, 0, 644, 646, 3, 152, 76, 0, 645, 
	644, 1, 0, 0, 0, 645, 646, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 649, 
	3, 204, 102, 0, 648, 650, 3, 52, 26, 0, 649, 648, 1, 0, 0, 0, 649, 650, 
	1, 0, 0, 0, 650, 111, 1, 0, 0, 0, 651, 652, 3, 18, 9, 0, 652, 653, 5, 36, 
	0, 0, 653, 658, 1, 0, 0, 0, 654, 655, 3, 16, 8, 0, 655, 656, 5, 43, 0, 
	0, 656, 658, 1, 0, 0, 0, 657, 651, 1, 0, 0, 0, 657, 654, 1, 0, 0, 0, 657, 
	658, 1, 0, 0, 0, 658, 659, 1, 0, 0, 0, 659, 660, 5, 19, 0, 0, 660, 661, 
	3, 152, 76, 0, 661, 113, 1, 0, 0, 0, 662, 663, 5, 8, 0, 0, 663, 664, 3, 
	152, 76, 0, 664, 115, 1, 0, 0, 0, 665, 667, 3, 120, 60, 0, 666, 668, 3, 
	118, 59, 0, 667, 666, 1, 0, 0, 0, 667, 668, 1, 0, 0, 0, 668, 675, 1, 0, 
	0, 0, 669, 675, 3, 122, 61, 0, 670, 671, 5, 30, 0, 0, 671, 672, 3, 116, 
	58, 0, 672, 673, 5, 31, 0, 0, 673, 675, 1, 0, 0, 0, 674, 665, 1, 0, 0, 
	0, 674, 669, 1, 0, 0, 0, 674, 670, 1, 0, 0, 0, 675, 117, 1, 0, 0, 0, 676, 
	677, 5, 34, 0, 0, 677, 679, 3, 98, 49, 0, 678, 680, 5, 37, 0, 0, 679, 678, 
	1, 0, 0, 0, 679, 680, 1, 0, 0, 0, 680, 681, 1, 0, 0, 0, 681, 682, 5, 35, 
	0, 0, 682, 119, 1, 0, 0, 0, 683, 686, 3, 168, 84, 0, 684, 686, 5, 29, 0, 
	0, 685, 683, 1, 0, 0, 0, 685, 684, 1, 0, 0, 0, 686, 121, 1, 0, 0, 0, 687, 
	696, 3, 124, 62, 0, 688, 696, 3, 184, 92, 0, 689, 696, 3, 130, 65, 0, 690, 
	696, 3, 142, 71, 0, 691, 696, 3, 132, 66, 0, 692, 696, 3, 134, 67, 0, 693, 
	696, 3, 136, 68, 0, 694, 696, 3, 138, 69, 0, 695, 687, 1, 0, 0, 0, 695, 
	688, 1, 0, 0, 0, 695, 689, 1, 0, 0, 0, 695, 690, 1, 0, 0, 0, 695, 691, 
	1, 0, 0, 0, 695, 692, 1, 0, 0, 0, 695, 693, 1, 0, 0, 0, 695, 694, 1, 0, 
	0, 0, 696, 123, 1, 0, 0, 0, 697, 698, 5, 34, 0, 0, 698, 699, 3, 126, 63, 
	0, 699, 700, 5, 35, 0, 0, 700, 701, 3, 128, 64, 0, 701, 125, 1, 0, 0, 0, 
	702, 703, 3, 152, 76, 0, 703, 127, 1, 0, 0, 0, 704, 705, 3, 116, 58, 0, 
	705, 129, 1, 0, 0, 0, 706, 707, 5, 64, 0, 0, 707, 708, 3, 116, 58, 0, 708, 
	131, 1, 0, 0, 0, 709, 710, 5, 4, 0, 0, 710, 719, 5, 32, 0, 0, 711, 714, 
	3, 140, 70, 0, 712, 714, 3, 32, 16, 0, 713, 711, 1, 0, 0, 0, 713, 712, 
	1, 0, 0, 0, 714, 715, 1, 0, 0, 0, 715, 716, 3, 204, 102, 0, 716, 718, 1, 
	0, 0, 0, 717, 713, 1, 0, 0, 0, 718, 721, 1, 0, 0, 0, 719, 717, 1, 0, 0, 
	0, 719, 720, 1, 0, 0, 0, 720, 722, 1, 0, 0, 0, 721, 719, 1, 0, 0, 0, 722, 
	723, 5, 33, 0, 0, 723, 133, 1, 0, 0, 0, 724, 725, 5, 34, 0, 0, 725, 726, 
	5, 35, 0, 0, 726, 727, 3, 128, 64, 0, 727, 135, 1, 0, 0, 0, 728, 729, 5, 
	9, 0, 0, 729, 730, 5, 34, 0, 0, 730, 731, 3, 116, 58, 0, 731, 732, 5, 35, 
	0, 0, 732, 733, 3, 128, 64, 0, 733, 137, 1, 0, 0, 0, 734, 740, 5, 11, 0, 
	0, 735, 736, 5, 11, 0, 0, 736, 740, 5, 66, 0, 0, 737, 738, 5, 66, 0, 0, 
	738, 740, 5, 11, 0, 0, 739, 734, 1, 0, 0, 0, 739, 735, 1, 0, 0, 0, 739, 
	737, 1, 0, 0, 0, 740, 741, 1, 0, 0, 0, 741, 742, 3, 128, 64, 0, 742, 139, 
	1, 0, 0, 0, 743, 744, 5, 29, 0, 0, 744, 745, 3, 148, 74, 0, 745, 746, 3, 
	146, 73, 0, 746, 750, 1, 0, 0, 0, 747, 748, 5, 29, 0, 0, 748, 750, 3, 148, 
	74, 0, 749, 743, 1, 0, 0, 0, 749, 747, 1, 0, 0, 0, 750, 141, 1, 0, 0, 0, 
	751, 752, 5, 3, 0, 0, 752, 753, 3, 144, 72, 0, 753, 143, 1, 0, 0, 0, 754, 
	756, 3, 148, 74, 0, 755, 757, 3, 146, 73, 0, 756, 755, 1, 0, 0, 0, 756, 
	757, 1, 0, 0, 0, 757, 145, 1, 0, 0, 0, 758, 761, 3, 148, 74, 0, 759, 761, 
	3, 116, 58, 0, 760, 758, 1, 0, 0, 0, 760, 759, 1, 0, 0, 0, 761, 147, 1, 
	0, 0, 0, 762, 774, 5, 30, 0, 0, 763, 768, 3, 150, 75, 0, 764, 765, 5, 37, 
	0, 0, 765, 767, 3, 150, 75, 0, 766, 764, 1, 0, 0, 0, 767, 770, 1, 0, 0, 
	0, 768, 766, 1, 0, 0, 0, 768, 769, 1, 0, 0, 0, 769, 772, 1, 0, 0, 0, 770, 
	768, 1, 0, 0, 0, 771, 773, 5, 37, 0, 0, 772, 771, 1, 0, 0, 0, 772, 773, 
	1, 0, 0, 0, 773, 775, 1, 0, 0, 0, 774, 763, 1, 0, 0, 0, 774, 775, 1, 0, 
	0, 0, 775, 776, 1, 0, 0, 0, 776, 777, 5, 31, 0, 0, 777, 149, 1, 0, 0, 0, 
	778, 780, 3, 16, 8, 0, 779, 778, 1, 0, 0, 0, 779, 780, 1, 0, 0, 0, 780, 
	782, 1, 0, 0, 0, 781, 783, 5, 44, 0, 0, 782, 781, 1, 0, 0, 0, 782, 783, 
	1, 0, 0, 0, 783, 784, 1, 0, 0, 0, 784, 785, 3, 116, 58, 0, 785, 151, 1, 
	0, 0, 0, 786, 787, 6, 76, -1, 0, 787, 791, 3, 154, 77, 0, 788, 789, 7, 
	3, 0, 0, 789, 791, 3, 152, 76, 6, 790, 786, 1, 0, 0, 0, 790, 788, 1, 0, 
	0, 0, 791, 809, 1, 0, 0, 0, 792, 793, 10, 5, 0, 0, 793, 794, 7, 4, 0, 0, 
	794, 808, 3, 152, 76, 6, 795, 796, 10, 4, 0, 0, 796, 797, 7, 5, 0, 0, 797, 
	808, 3, 152, 76, 5, 798, 799, 10, 3, 0, 0, 799, 800, 7, 6, 0, 0, 800, 808, 
	3, 152, 76, 4, 801, 802, 10, 2, 0, 0, 802, 803, 5, 46, 0, 0, 803, 808, 
	3, 152, 76, 3, 804, 805, 10, 1, 0, 0, 805, 806, 5, 45, 0, 0, 806, 808, 
	3, 152, 76, 2, 807, 792, 1, 0, 0, 0, 807, 795, 1, 0, 0, 0, 807, 798, 1, 
	0, 0, 0, 807, 801, 1, 0, 0, 0, 807, 804, 1, 0, 0, 0, 808, 811, 1, 0, 0, 
	0, 809, 807, 1, 0, 0, 0, 809, 810, 1, 0, 0, 0, 810, 153, 1, 0, 0, 0, 811, 
	809, 1, 0, 0, 0, 812, 813, 6, 77, -1, 0, 813, 817, 3, 158, 79, 0, 814, 
	817, 3, 156, 78, 0, 815, 817, 3, 202, 101, 0, 816, 812, 1, 0, 0, 0, 816, 
	814, 1, 0, 0, 0, 816, 815, 1, 0, 0, 0, 817, 829, 1, 0, 0, 0, 818, 825, 
	10, 1, 0, 0, 819, 820, 5, 40, 0, 0, 820, 826, 5, 29, 0, 0, 821, 826, 3, 
	194, 97, 0, 822, 826, 3, 196, 98, 0, 823, 826, 3, 198, 99, 0, 824, 826, 
	3, 200, 100, 0, 825, 819, 1, 0, 0, 0, 825, 821, 1, 0, 0, 0, 825, 822, 1, 
	0, 0, 0, 825, 823, 1, 0, 0, 0, 825, 824, 1, 0, 0, 0, 826, 828, 1, 0, 0, 
	0, 827, 818, 1, 0, 0, 0, 828, 831, 1, 0, 0, 0, 829, 827, 1, 0, 0, 0, 829, 
	830, 1, 0, 0, 0, 830, 155, 1, 0, 0, 0, 831, 829, 1, 0, 0, 0, 832, 833, 
	3, 116, 58, 0, 833, 834, 5, 30, 0, 0, 834, 836, 3, 152, 76, 0, 835, 837, 
	5, 37, 0, 0, 836, 835, 1, 0, 0, 0, 836, 837, 1, 0, 0, 0, 837, 838, 1, 0, 
	0, 0, 838, 839, 5, 31, 0, 0, 839, 157, 1, 0, 0, 0, 840, 847, 3, 160, 80, 
	0, 841, 847, 3, 166, 83, 0, 842, 843, 5, 30, 0, 0, 843, 844, 3, 152, 76, 
	0, 844, 845, 5, 31, 0, 0, 845, 847, 1, 0, 0, 0, 846, 840, 1, 0, 0, 0, 846, 
	841, 1, 0, 0, 0, 846, 842, 1, 0, 0, 0, 847, 159, 1, 0, 0, 0, 848, 852, 
	3, 162, 81, 0, 849, 852, 3, 170, 85, 0, 850, 852, 3, 192, 96, 0, 851, 848, 
	1, 0, 0, 0, 851, 849, 1, 0, 0, 0, 851, 850, 1, 0, 0, 0, 852, 161, 1, 0, 
	0, 0, 853, 860, 5, 26, 0, 0, 854, 860, 3, 164, 82, 0, 855, 860, 3, 188, 
	94, 0, 856, 860, 5, 71, 0, 0, 857, 860, 5, 27, 0, 0, 858, 860, 5, 28, 0, 
	0, 859, 853, 1, 0, 0, 0, 859, 854, 1, 0, 0, 0, 859, 855, 1, 0, 0, 0, 859, 
	856, 1, 0, 0, 0, 859, 857, 1, 0, 0, 0, 859, 858, 1, 0, 0, 0, 860, 163, 
	1, 0, 0, 0, 861, 862, 7, 7, 0, 0, 862, 165, 1, 0, 0, 0, 863, 864, 5, 29, 
	0, 0, 864, 167, 1, 0, 0, 0, 865, 866, 5, 29, 0, 0, 866, 867, 5, 40, 0, 
	0, 867, 868, 5, 29, 0, 0, 868, 169, 1, 0, 0, 0, 869, 870, 3, 172, 86, 0, 
	870, 871, 3, 174, 87, 0, 871, 171, 1, 0, 0, 0, 872, 885, 3, 184, 92, 0, 
	873, 885, 3, 124, 62, 0, 874, 875, 5, 34, 0, 0, 875, 876, 5, 44, 0, 0, 
	876, 877, 5, 35, 0, 0, 877, 885, 3, 128, 64, 0, 878, 885, 3, 134, 67, 0, 
	879, 885, 3, 136, 68, 0, 880, 882, 3, 120, 60, 0, 881, 883, 3, 118, 59, 
	0, 882, 881, 1, 0, 0, 0, 882, 883, 1, 0, 0, 0, 883, 885, 1, 0, 0, 0, 884, 
	872, 1, 0, 0, 0, 884, 873, 1, 0, 0, 0, 884, 874, 1, 0, 0, 0, 884, 878, 
	1, 0, 0, 0, 884, 879, 1, 0, 0, 0, 884, 880, 1, 0, 0, 0, 885, 173, 1, 0, 
	0, 0, 886, 891, 5, 32, 0, 0, 887, 889, 3, 176, 88, 0, 888, 890, 5, 37, 
	0, 0, 889, 888, 1, 0, 0, 0, 889, 890, 1, 0, 0, 0, 890, 892, 1, 0, 0, 0, 
	891, 887, 1, 0, 0, 0, 891, 892, 1, 0, 0, 0, 892, 893, 1, 0, 0, 0, 893, 
	894, 5, 33, 0, 0, 894, 175, 1, 0, 0, 0, 895, 900, 3, 178, 89, 0, 896, 897, 
	5, 37, 0, 0, 897, 899, 3, 178, 89, 0, 898, 896, 1, 0, 0, 0, 899, 902, 1, 
	0, 0, 0, 900, 898, 1, 0, 0, 0, 900, 901, 1, 0, 0, 0, 901, 177, 1, 0, 0, 
	0, 902, 900, 1, 0, 0, 0, 903, 904, 3, 180, 90, 0, 904, 905, 5, 39, 0, 0, 
	905, 907, 1, 0, 0, 0, 906, 903, 1, 0, 0, 0, 906, 907, 1, 0, 0, 0, 907, 
	908, 1, 0, 0, 0, 908, 909, 3, 182, 91, 0, 909, 179, 1, 0, 0, 0, 910, 913, 
	3, 152, 76, 0, 911, 913, 3, 174, 87, 0, 912, 910, 1, 0, 0, 0, 912, 911, 
	1, 0, 0, 0, 913, 181, 1, 0, 0, 0, 914, 917, 3, 152, 76, 0, 915, 917, 3, 
	174, 87, 0, 916, 914, 1, 0, 0, 0, 916, 915, 1, 0, 0, 0, 917, 183, 1, 0, 
	0, 0, 918, 919, 5, 10, 0, 0, 919, 925, 5, 32, 0, 0, 920, 921, 3, 186, 93, 
	0, 921, 922, 3, 204, 102, 0, 922, 924, 1, 0, 0, 0, 923, 920, 1, 0, 0, 0, 
	924, 927, 1, 0, 0, 0, 925, 923, 1, 0, 0, 0, 925, 926, 1, 0, 0, 0, 926, 
	928, 1, 0, 0, 0, 927, 925, 1, 0, 0, 0, 928, 929, 5, 33, 0, 0, 929, 185, 
	1, 0, 0, 0, 930, 931, 3, 16, 8, 0, 931, 932, 3, 116, 58, 0, 932, 935, 1, 
	0, 0, 0, 933, 935, 3, 190, 95, 0, 934, 930, 1, 0, 0, 0, 934, 933, 1, 0, 
	0, 0, 935, 937, 1, 0, 0, 0, 936, 938, 3, 188, 94, 0, 937, 936, 1, 0, 0, 
	0, 937, 938, 1, 0, 0, 0, 938, 187, 1, 0, 0, 0, 939, 940, 7, 8, 0, 0, 940, 
	189, 1, 0, 0, 0, 941, 943, 5, 64, 0, 0, 942, 941, 1, 0, 0, 0, 942, 943, 
	1, 0, 0, 0, 943, 944, 1, 0, 0, 0, 944, 946, 3, 120, 60, 0, 945, 947, 3, 
	118, 59, 0, 946, 945, 1, 0, 0, 0, 946, 947, 1, 0, 0, 0, 947, 191, 1, 0, 
	0, 0, 948, 949, 5, 3, 0, 0, 949, 950, 3, 144, 72, 0, 950, 951, 3, 46, 23, 
	0, 951, 193, 1, 0, 0, 0, 952, 953, 5, 34, 0, 0, 953, 954, 3, 152, 76, 0, 
	954, 955, 5, 35, 0, 0, 955, 195, 1, 0, 0, 0, 956, 972, 5, 34, 0, 0, 957, 
	959, 3, 152, 76, 0, 958, 957, 1, 0, 0, 0, 958, 959, 1, 0, 0, 0, 959, 960, 
	1, 0, 0, 0, 960, 962, 5, 39, 0, 0, 961, 963, 3, 152, 76, 0, 962, 961, 1, 
	0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 973, 1, 0, 0, 0, 964, 966, 3, 152, 
	76, 0, 965, 964, 1, 0, 0, 0, 965, 966, 1, 0, 0, 0, 966, 967, 1, 0, 0, 0, 
	967, 968, 5, 39, 0, 0, 968, 969, 3, 152, 76, 0, 969, 970, 5, 39, 0, 0, 
	970, 971, 3, 152, 76, 0, 971, 973, 1, 0, 0, 0, 972, 958, 1, 0, 0, 0, 972, 
	965, 1, 0, 0, 0, 973, 974, 1, 0, 0, 0, 974, 975, 5, 35, 0, 0, 975, 197, 
	1, 0, 0, 0, 976, 977, 5, 40, 0, 0, 977, 978, 5, 30, 0, 0, 978, 979, 3, 
	116, 58, 0, 979, 980, 5, 31, 0, 0, 980, 199, 1, 0, 0, 0, 981, 996, 5, 30, 
	0, 0, 982, 989, 3, 18, 9, 0, 983, 986, 3, 116, 58, 0, 984, 985, 5, 37, 
	0, 0, 985, 987, 3, 18, 9, 0, 986, 984, 1, 0, 0, 0, 986, 987, 1, 0, 0, 0, 
	987, 989, 1, 0, 0, 0, 988, 982, 1, 0, 0, 0, 988, 983, 1, 0, 0, 0, 989, 
	991, 1, 0, 0, 0, 990, 992, 5, 44, 0, 0, 991, 990, 1, 0, 0, 0, 991, 992, 
	1, 0, 0, 0, 992, 994, 1, 0, 0, 0, 993, 995, 5, 37, 0, 0, 994, 993, 1, 0, 
	0, 0, 994, 995, 1, 0, 0, 0, 995, 997, 1, 0, 0, 0, 996, 988, 1, 0, 0, 0, 
	996, 997, 1, 0, 0, 0, 997, 998, 1, 0, 0, 0, 998, 999, 5, 31, 0, 0, 999, 
	201, 1, 0, 0, 0, 1000, 1001, 3, 116, 58, 0, 1001, 1002, 5, 40, 0, 0, 1002, 
	1003, 5, 29, 0, 0, 1003, 203, 1, 0, 0, 0, 1004, 1005, 7, 9, 0, 0, 1005, 
	205, 1, 0, 0, 0, 118, 213, 219, 225, 241, 245, 248, 257, 267, 271, 275, 
	279, 286, 294, 305, 309, 313, 321, 331, 344, 348, 355, 359, 366, 378, 382, 
	388, 392, 396, 401, 404, 406, 413, 430, 437, 453, 464, 468, 472, 476, 495, 
	501, 503, 507, 511, 514, 518, 520, 526, 534, 539, 550, 556, 563, 574, 579, 
	583, 588, 592, 600, 608, 613, 616, 624, 630, 634, 636, 641, 645, 649, 657, 
	667, 674, 679, 685, 695, 713, 719, 739, 749, 756, 760, 768, 772, 774, 779, 
	782, 790, 807, 809, 816, 825, 829, 836, 846, 851, 859, 882, 884, 889, 891, 
	900, 906, 912, 916, 925, 934, 937, 942, 946, 958, 962, 965, 972, 986, 988, 
	991, 994, 996,
}
  deserializer := antlr.NewATNDeserializer(nil)
  staticData.atn = deserializer.Deserialize(staticData.serializedATN)
  atn := staticData.atn
  staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
  decisionToDFA := staticData.decisionToDFA
  for index, state := range atn.DecisionToState {
    decisionToDFA[index] = antlr.NewDFA(state, index)
  }
}

// GoParserInit initializes any static state used to implement GoParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewGoParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func GoParserInit() {
  staticData := &GoParserParserStaticData
  staticData.once.Do(goparserParserInit)
}

// NewGoParser produces a new parser instance for the optional input antlr.TokenStream.
func NewGoParser(input antlr.TokenStream) *GoParser {
	GoParserInit()
	this := new(GoParser)
	this.BaseParser = antlr.NewBaseParser(input)
  staticData := &GoParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "GoParser.g4"

	return this
}


// GoParser tokens.
const (
	GoParserEOF = antlr.TokenEOF
	GoParserBREAK = 1
	GoParserDEFAULT = 2
	GoParserFUNC = 3
	GoParserINTERFACE = 4
	GoParserSELECT = 5
	GoParserCASE = 6
	GoParserDEFER = 7
	GoParserGO = 8
	GoParserMAP = 9
	GoParserSTRUCT = 10
	GoParserCHAN = 11
	GoParserELSE = 12
	GoParserGOTO = 13
	GoParserPACKAGE = 14
	GoParserSWITCH = 15
	GoParserCONST = 16
	GoParserFALLTHROUGH = 17
	GoParserIF = 18
	GoParserRANGE = 19
	GoParserTYPE = 20
	GoParserCONTINUE = 21
	GoParserFOR = 22
	GoParserIMPORT = 23
	GoParserRETURN = 24
	GoParserVAR = 25
	GoParserNIL_LIT = 26
	GoParserTRUE_LIT = 27
	GoParserFALSE_LIT = 28
	GoParserIDENTIFIER = 29
	GoParserL_PAREN = 30
	GoParserR_PAREN = 31
	GoParserL_CURLY = 32
	GoParserR_CURLY = 33
	GoParserL_BRACKET = 34
	GoParserR_BRACKET = 35
	GoParserASSIGN = 36
	GoParserCOMMA = 37
	GoParserSEMI = 38
	GoParserCOLON = 39
	GoParserDOT = 40
	GoParserPLUS_PLUS = 41
	GoParserMINUS_MINUS = 42
	GoParserDECLARE_ASSIGN = 43
	GoParserELLIPSIS = 44
	GoParserLOGICAL_OR = 45
	GoParserLOGICAL_AND = 46
	GoParserEQUALS = 47
	GoParserNOT_EQUALS = 48
	GoParserLESS = 49
	GoParserLESS_OR_EQUALS = 50
	GoParserGREATER = 51
	GoParserGREATER_OR_EQUALS = 52
	GoParserOR = 53
	GoParserDIV = 54
	GoParserMOD = 55
	GoParserLSHIFT = 56
	GoParserRSHIFT = 57
	GoParserBIT_CLEAR = 58
	GoParserUNDERLYING = 59
	GoParserEXCLAMATION = 60
	GoParserPLUS = 61
	GoParserMINUS = 62
	GoParserCARET = 63
	GoParserSTAR = 64
	GoParserAMPERSAND = 65
	GoParserRECEIVE = 66
	GoParserDECIMAL_LIT = 67
	GoParserBINARY_LIT = 68
	GoParserOCTAL_LIT = 69
	GoParserHEX_LIT = 70
	GoParserFLOAT_LIT = 71
	GoParserDECIMAL_FLOAT_LIT = 72
	GoParserHEX_FLOAT_LIT = 73
	GoParserIMAGINARY_LIT = 74
	GoParserRUNE_LIT = 75
	GoParserBYTE_VALUE = 76
	GoParserOCTAL_BYTE_VALUE = 77
	GoParserHEX_BYTE_VALUE = 78
	GoParserLITTLE_U_VALUE = 79
	GoParserBIG_U_VALUE = 80
	GoParserRAW_STRING_LIT = 81
	GoParserINTERPRETED_STRING_LIT = 82
	GoParserWS = 83
	GoParserCOMMENT = 84
	GoParserTERMINATOR = 85
	GoParserLINE_COMMENT = 86
	GoParserWS_NLSEMI = 87
	GoParserCOMMENT_NLSEMI = 88
	GoParserLINE_COMMENT_NLSEMI = 89
	GoParserEOS = 90
	GoParserOTHER = 91
)

// GoParser rules.
const (
	GoParserRULE_sourceFile = 0
	GoParserRULE_packageClause = 1
	GoParserRULE_importDecl = 2
	GoParserRULE_importSpec = 3
	GoParserRULE_importPath = 4
	GoParserRULE_declaration = 5
	GoParserRULE_constDecl = 6
	GoParserRULE_constSpec = 7
	GoParserRULE_identifierList = 8
	GoParserRULE_expressionList = 9
	GoParserRULE_typeDecl = 10
	GoParserRULE_typeSpec = 11
	GoParserRULE_aliasDecl = 12
	GoParserRULE_typeDef = 13
	GoParserRULE_typeParameters = 14
	GoParserRULE_typeParameterDecl = 15
	GoParserRULE_typeElement = 16
	GoParserRULE_typeTerm = 17
	GoParserRULE_functionDecl = 18
	GoParserRULE_methodDecl = 19
	GoParserRULE_receiver = 20
	GoParserRULE_varDecl = 21
	GoParserRULE_varSpec = 22
	GoParserRULE_block = 23
	GoParserRULE_statementList = 24
	GoParserRULE_statement = 25
	GoParserRULE_simpleStmt = 26
	GoParserRULE_expressionStmt = 27
	GoParserRULE_sendStmt = 28
	GoParserRULE_incDecStmt = 29
	GoParserRULE_assignment = 30
	GoParserRULE_assign_op = 31
	GoParserRULE_shortVarDecl = 32
	GoParserRULE_labeledStmt = 33
	GoParserRULE_returnStmt = 34
	GoParserRULE_breakStmt = 35
	GoParserRULE_continueStmt = 36
	GoParserRULE_gotoStmt = 37
	GoParserRULE_fallthroughStmt = 38
	GoParserRULE_deferStmt = 39
	GoParserRULE_ifStmt = 40
	GoParserRULE_switchStmt = 41
	GoParserRULE_exprSwitchStmt = 42
	GoParserRULE_exprCaseClause = 43
	GoParserRULE_exprSwitchCase = 44
	GoParserRULE_typeSwitchStmt = 45
	GoParserRULE_typeSwitchGuard = 46
	GoParserRULE_typeCaseClause = 47
	GoParserRULE_typeSwitchCase = 48
	GoParserRULE_typeList = 49
	GoParserRULE_selectStmt = 50
	GoParserRULE_commClause = 51
	GoParserRULE_commCase = 52
	GoParserRULE_recvStmt = 53
	GoParserRULE_forStmt = 54
	GoParserRULE_forClause = 55
	GoParserRULE_rangeClause = 56
	GoParserRULE_goStmt = 57
	GoParserRULE_type_ = 58
	GoParserRULE_typeArgs = 59
	GoParserRULE_typeName = 60
	GoParserRULE_typeLit = 61
	GoParserRULE_arrayType = 62
	GoParserRULE_arrayLength = 63
	GoParserRULE_elementType = 64
	GoParserRULE_pointerType = 65
	GoParserRULE_interfaceType = 66
	GoParserRULE_sliceType = 67
	GoParserRULE_mapType = 68
	GoParserRULE_channelType = 69
	GoParserRULE_methodSpec = 70
	GoParserRULE_functionType = 71
	GoParserRULE_signature = 72
	GoParserRULE_result = 73
	GoParserRULE_parameters = 74
	GoParserRULE_parameterDecl = 75
	GoParserRULE_expression = 76
	GoParserRULE_primaryExpr = 77
	GoParserRULE_conversion = 78
	GoParserRULE_operand = 79
	GoParserRULE_literal = 80
	GoParserRULE_basicLit = 81
	GoParserRULE_integer = 82
	GoParserRULE_operandName = 83
	GoParserRULE_qualifiedIdent = 84
	GoParserRULE_compositeLit = 85
	GoParserRULE_literalType = 86
	GoParserRULE_literalValue = 87
	GoParserRULE_elementList = 88
	GoParserRULE_keyedElement = 89
	GoParserRULE_key = 90
	GoParserRULE_element = 91
	GoParserRULE_structType = 92
	GoParserRULE_fieldDecl = 93
	GoParserRULE_string_ = 94
	GoParserRULE_embeddedField = 95
	GoParserRULE_functionLit = 96
	GoParserRULE_index = 97
	GoParserRULE_slice_ = 98
	GoParserRULE_typeAssertion = 99
	GoParserRULE_arguments = 100
	GoParserRULE_methodExpr = 101
	GoParserRULE_eos = 102
)

// ISourceFileContext is an interface to support dynamic dispatch.
type ISourceFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PackageClause() IPackageClauseContext
	AllEos() []IEosContext
	Eos(i int) IEosContext
	EOF() antlr.TerminalNode
	AllImportDecl() []IImportDeclContext
	ImportDecl(i int) IImportDeclContext
	AllFunctionDecl() []IFunctionDeclContext
	FunctionDecl(i int) IFunctionDeclContext
	AllMethodDecl() []IMethodDeclContext
	MethodDecl(i int) IMethodDeclContext
	AllDeclaration() []IDeclarationContext
	Declaration(i int) IDeclarationContext

	// IsSourceFileContext differentiates from other interfaces.
	IsSourceFileContext()
}

type SourceFileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceFileContext() *SourceFileContext {
	var p = new(SourceFileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_sourceFile
	return p
}

func InitEmptySourceFileContext(p *SourceFileContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_sourceFile
}

func (*SourceFileContext) IsSourceFileContext() {}

func NewSourceFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceFileContext {
	var p = new(SourceFileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_sourceFile

	return p
}

func (s *SourceFileContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceFileContext) PackageClause() IPackageClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageClauseContext)
}

func (s *SourceFileContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *SourceFileContext) Eos(i int) IEosContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *SourceFileContext) EOF() antlr.TerminalNode {
	return s.GetToken(GoParserEOF, 0)
}

func (s *SourceFileContext) AllImportDecl() []IImportDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDeclContext); ok {
			len++
		}
	}

	tst := make([]IImportDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDeclContext); ok {
			tst[i] = t.(IImportDeclContext)
			i++
		}
	}

	return tst
}

func (s *SourceFileContext) ImportDecl(i int) IImportDeclContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclContext)
}

func (s *SourceFileContext) AllFunctionDecl() []IFunctionDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDeclContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDeclContext); ok {
			tst[i] = t.(IFunctionDeclContext)
			i++
		}
	}

	return tst
}

func (s *SourceFileContext) FunctionDecl(i int) IFunctionDeclContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclContext)
}

func (s *SourceFileContext) AllMethodDecl() []IMethodDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodDeclContext); ok {
			len++
		}
	}

	tst := make([]IMethodDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodDeclContext); ok {
			tst[i] = t.(IMethodDeclContext)
			i++
		}
	}

	return tst
}

func (s *SourceFileContext) MethodDecl(i int) IMethodDeclContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclContext)
}

func (s *SourceFileContext) AllDeclaration() []IDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationContext); ok {
			tst[i] = t.(IDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *SourceFileContext) Declaration(i int) IDeclarationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *SourceFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SourceFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterSourceFile(s)
	}
}

func (s *SourceFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitSourceFile(s)
	}
}

func (s *SourceFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitSourceFile(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) SourceFile() (localctx ISourceFileContext) {
	localctx = NewSourceFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, GoParserRULE_sourceFile)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(206)
		p.PackageClause()
	}
	{
		p.SetState(207)
		p.Eos()
	}
	p.SetState(213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoParserIMPORT {
		{
			p.SetState(208)
			p.ImportDecl()
		}
		{
			p.SetState(209)
			p.Eos()
		}


		p.SetState(215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 34668552) != 0) {
		p.SetState(219)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(216)
				p.FunctionDecl()
			}


		case 2:
			{
				p.SetState(217)
				p.MethodDecl()
			}


		case 3:
			{
				p.SetState(218)
				p.Declaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(221)
			p.Eos()
		}


		p.SetState(227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(228)
		p.Match(GoParserEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPackageClauseContext is an interface to support dynamic dispatch.
type IPackageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPackageName returns the packageName token.
	GetPackageName() antlr.Token 


	// SetPackageName sets the packageName token.
	SetPackageName(antlr.Token) 


	// Getter signatures
	PACKAGE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsPackageClauseContext differentiates from other interfaces.
	IsPackageClauseContext()
}

type PackageClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	packageName antlr.Token
}

func NewEmptyPackageClauseContext() *PackageClauseContext {
	var p = new(PackageClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_packageClause
	return p
}

func InitEmptyPackageClauseContext(p *PackageClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_packageClause
}

func (*PackageClauseContext) IsPackageClauseContext() {}

func NewPackageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageClauseContext {
	var p = new(PackageClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_packageClause

	return p
}

func (s *PackageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageClauseContext) GetPackageName() antlr.Token { return s.packageName }


func (s *PackageClauseContext) SetPackageName(v antlr.Token) { s.packageName = v }


func (s *PackageClauseContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(GoParserPACKAGE, 0)
}

func (s *PackageClauseContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *PackageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PackageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterPackageClause(s)
	}
}

func (s *PackageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitPackageClause(s)
	}
}

func (s *PackageClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitPackageClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) PackageClause() (localctx IPackageClauseContext) {
	localctx = NewPackageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, GoParserRULE_packageClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(230)
		p.Match(GoParserPACKAGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(231)

		var _m = p.Match(GoParserIDENTIFIER)

		localctx.(*PackageClauseContext).packageName = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IImportDeclContext is an interface to support dynamic dispatch.
type IImportDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	AllImportSpec() []IImportSpecContext
	ImportSpec(i int) IImportSpecContext
	L_PAREN() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	AllEos() []IEosContext
	Eos(i int) IEosContext

	// IsImportDeclContext differentiates from other interfaces.
	IsImportDeclContext()
}

type ImportDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclContext() *ImportDeclContext {
	var p = new(ImportDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_importDecl
	return p
}

func InitEmptyImportDeclContext(p *ImportDeclContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_importDecl
}

func (*ImportDeclContext) IsImportDeclContext() {}

func NewImportDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclContext {
	var p = new(ImportDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_importDecl

	return p
}

func (s *ImportDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(GoParserIMPORT, 0)
}

func (s *ImportDeclContext) AllImportSpec() []IImportSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportSpecContext); ok {
			len++
		}
	}

	tst := make([]IImportSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportSpecContext); ok {
			tst[i] = t.(IImportSpecContext)
			i++
		}
	}

	return tst
}

func (s *ImportDeclContext) ImportSpec(i int) IImportSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportSpecContext)
}

func (s *ImportDeclContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserL_PAREN, 0)
}

func (s *ImportDeclContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserR_PAREN, 0)
}

func (s *ImportDeclContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ImportDeclContext) Eos(i int) IEosContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ImportDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ImportDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterImportDecl(s)
	}
}

func (s *ImportDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitImportDecl(s)
	}
}

func (s *ImportDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitImportDecl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ImportDecl() (localctx IImportDeclContext) {
	localctx = NewImportDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, GoParserRULE_importDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(233)
		p.Match(GoParserIMPORT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserIDENTIFIER, GoParserDOT, GoParserRAW_STRING_LIT, GoParserINTERPRETED_STRING_LIT:
		{
			p.SetState(234)
			p.ImportSpec()
		}


	case GoParserL_PAREN:
		{
			p.SetState(235)
			p.Match(GoParserL_PAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(241)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ((int64((_la - 29)) & ^0x3f) == 0 && ((int64(1) << (_la - 29)) & 13510798882113537) != 0) {
			{
				p.SetState(236)
				p.ImportSpec()
			}
			{
				p.SetState(237)
				p.Eos()
			}


			p.SetState(243)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(244)
			p.Match(GoParserR_PAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IImportSpecContext is an interface to support dynamic dispatch.
type IImportSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlias returns the alias token.
	GetAlias() antlr.Token 


	// SetAlias sets the alias token.
	SetAlias(antlr.Token) 


	// Getter signatures
	ImportPath() IImportPathContext
	DOT() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsImportSpecContext differentiates from other interfaces.
	IsImportSpecContext()
}

type ImportSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	alias antlr.Token
}

func NewEmptyImportSpecContext() *ImportSpecContext {
	var p = new(ImportSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_importSpec
	return p
}

func InitEmptyImportSpecContext(p *ImportSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_importSpec
}

func (*ImportSpecContext) IsImportSpecContext() {}

func NewImportSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportSpecContext {
	var p = new(ImportSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_importSpec

	return p
}

func (s *ImportSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportSpecContext) GetAlias() antlr.Token { return s.alias }


func (s *ImportSpecContext) SetAlias(v antlr.Token) { s.alias = v }


func (s *ImportSpecContext) ImportPath() IImportPathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportPathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportPathContext)
}

func (s *ImportSpecContext) DOT() antlr.TerminalNode {
	return s.GetToken(GoParserDOT, 0)
}

func (s *ImportSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *ImportSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ImportSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterImportSpec(s)
	}
}

func (s *ImportSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitImportSpec(s)
	}
}

func (s *ImportSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitImportSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ImportSpec() (localctx IImportSpecContext) {
	localctx = NewImportSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, GoParserRULE_importSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserIDENTIFIER || _la == GoParserDOT {
		{
			p.SetState(247)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ImportSpecContext).alias = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == GoParserIDENTIFIER || _la == GoParserDOT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ImportSpecContext).alias = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(250)
		p.ImportPath()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IImportPathContext is an interface to support dynamic dispatch.
type IImportPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	String_() IString_Context

	// IsImportPathContext differentiates from other interfaces.
	IsImportPathContext()
}

type ImportPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportPathContext() *ImportPathContext {
	var p = new(ImportPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_importPath
	return p
}

func InitEmptyImportPathContext(p *ImportPathContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_importPath
}

func (*ImportPathContext) IsImportPathContext() {}

func NewImportPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportPathContext {
	var p = new(ImportPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_importPath

	return p
}

func (s *ImportPathContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportPathContext) String_() IString_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ImportPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ImportPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterImportPath(s)
	}
}

func (s *ImportPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitImportPath(s)
	}
}

func (s *ImportPathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitImportPath(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ImportPath() (localctx IImportPathContext) {
	localctx = NewImportPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, GoParserRULE_importPath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(252)
		p.String_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstDecl() IConstDeclContext
	TypeDecl() ITypeDeclContext
	VarDecl() IVarDeclContext

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_declaration
	return p
}

func InitEmptyDeclarationContext(p *DeclarationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_declaration
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) ConstDecl() IConstDeclContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstDeclContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstDeclContext)
}

func (s *DeclarationContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *DeclarationContext) VarDecl() IVarDeclContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarDeclContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarDeclContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, GoParserRULE_declaration)
	p.SetState(257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserCONST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(254)
			p.ConstDecl()
		}


	case GoParserTYPE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(255)
			p.TypeDecl()
		}


	case GoParserVAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(256)
			p.VarDecl()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConstDeclContext is an interface to support dynamic dispatch.
type IConstDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode
	AllConstSpec() []IConstSpecContext
	ConstSpec(i int) IConstSpecContext
	L_PAREN() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	AllEos() []IEosContext
	Eos(i int) IEosContext

	// IsConstDeclContext differentiates from other interfaces.
	IsConstDeclContext()
}

type ConstDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstDeclContext() *ConstDeclContext {
	var p = new(ConstDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_constDecl
	return p
}

func InitEmptyConstDeclContext(p *ConstDeclContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_constDecl
}

func (*ConstDeclContext) IsConstDeclContext() {}

func NewConstDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstDeclContext {
	var p = new(ConstDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_constDecl

	return p
}

func (s *ConstDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstDeclContext) CONST() antlr.TerminalNode {
	return s.GetToken(GoParserCONST, 0)
}

func (s *ConstDeclContext) AllConstSpec() []IConstSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstSpecContext); ok {
			len++
		}
	}

	tst := make([]IConstSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstSpecContext); ok {
			tst[i] = t.(IConstSpecContext)
			i++
		}
	}

	return tst
}

func (s *ConstDeclContext) ConstSpec(i int) IConstSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstSpecContext)
}

func (s *ConstDeclContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserL_PAREN, 0)
}

func (s *ConstDeclContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserR_PAREN, 0)
}

func (s *ConstDeclContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ConstDeclContext) Eos(i int) IEosContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ConstDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConstDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterConstDecl(s)
	}
}

func (s *ConstDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitConstDecl(s)
	}
}

func (s *ConstDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitConstDecl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ConstDecl() (localctx IConstDeclContext) {
	localctx = NewConstDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, GoParserRULE_constDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(259)
		p.Match(GoParserCONST)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserIDENTIFIER:
		{
			p.SetState(260)
			p.ConstSpec()
		}


	case GoParserL_PAREN:
		{
			p.SetState(261)
			p.Match(GoParserL_PAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == GoParserIDENTIFIER {
			{
				p.SetState(262)
				p.ConstSpec()
			}
			{
				p.SetState(263)
				p.Eos()
			}


			p.SetState(269)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(270)
			p.Match(GoParserR_PAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConstSpecContext is an interface to support dynamic dispatch.
type IConstSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	ASSIGN() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	Type_() IType_Context

	// IsConstSpecContext differentiates from other interfaces.
	IsConstSpecContext()
}

type ConstSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstSpecContext() *ConstSpecContext {
	var p = new(ConstSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_constSpec
	return p
}

func InitEmptyConstSpecContext(p *ConstSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_constSpec
}

func (*ConstSpecContext) IsConstSpecContext() {}

func NewConstSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstSpecContext {
	var p = new(ConstSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_constSpec

	return p
}

func (s *ConstSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstSpecContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ConstSpecContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GoParserASSIGN, 0)
}

func (s *ConstSpecContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ConstSpecContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ConstSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConstSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterConstSpec(s)
	}
}

func (s *ConstSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitConstSpec(s)
	}
}

func (s *ConstSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitConstSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ConstSpec() (localctx IConstSpecContext) {
	localctx = NewConstSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, GoParserRULE_constSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(273)
		p.IdentifierList()
	}
	p.SetState(279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 3)) & ^0x3f) == 0 && ((int64(1) << (_la - 3)) & -6917529016702336573) != 0) {
		p.SetState(275)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64((_la - 3)) & ^0x3f) == 0 && ((int64(1) << (_la - 3)) & -6917529025292271165) != 0) {
			{
				p.SetState(274)
				p.Type_()
			}

		}
		{
			p.SetState(277)
			p.Match(GoParserASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(278)
			p.ExpressionList()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(GoParserIDENTIFIER)
}

func (s *IdentifierListContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, i)
}

func (s *IdentifierListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GoParserCOMMA)
}

func (s *IdentifierListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GoParserCOMMA, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, GoParserRULE_identifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(281)
		p.Match(GoParserIDENTIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoParserCOMMA {
		{
			p.SetState(282)
			p.Match(GoParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(283)
			p.Match(GoParserIDENTIFIER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GoParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GoParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, GoParserRULE_expressionList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(289)
		p.expression(0)
	}
	p.SetState(294)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(290)
				p.Match(GoParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(291)
				p.expression(0)
			}


		}
		p.SetState(296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeDeclContext is an interface to support dynamic dispatch.
type ITypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	AllTypeSpec() []ITypeSpecContext
	TypeSpec(i int) ITypeSpecContext
	L_PAREN() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	AllEos() []IEosContext
	Eos(i int) IEosContext

	// IsTypeDeclContext differentiates from other interfaces.
	IsTypeDeclContext()
}

type TypeDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclContext() *TypeDeclContext {
	var p = new(TypeDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeDecl
	return p
}

func InitEmptyTypeDeclContext(p *TypeDeclContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeDecl
}

func (*TypeDeclContext) IsTypeDeclContext() {}

func NewTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclContext {
	var p = new(TypeDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeDecl

	return p
}

func (s *TypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclContext) TYPE() antlr.TerminalNode {
	return s.GetToken(GoParserTYPE, 0)
}

func (s *TypeDeclContext) AllTypeSpec() []ITypeSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeSpecContext); ok {
			len++
		}
	}

	tst := make([]ITypeSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeSpecContext); ok {
			tst[i] = t.(ITypeSpecContext)
			i++
		}
	}

	return tst
}

func (s *TypeDeclContext) TypeSpec(i int) ITypeSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecContext)
}

func (s *TypeDeclContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserL_PAREN, 0)
}

func (s *TypeDeclContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserR_PAREN, 0)
}

func (s *TypeDeclContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *TypeDeclContext) Eos(i int) IEosContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *TypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeDecl(s)
	}
}

func (s *TypeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeDecl(s)
	}
}

func (s *TypeDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeDecl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeDecl() (localctx ITypeDeclContext) {
	localctx = NewTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, GoParserRULE_typeDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(297)
		p.Match(GoParserTYPE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(309)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserIDENTIFIER:
		{
			p.SetState(298)
			p.TypeSpec()
		}


	case GoParserL_PAREN:
		{
			p.SetState(299)
			p.Match(GoParserL_PAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(305)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == GoParserIDENTIFIER {
			{
				p.SetState(300)
				p.TypeSpec()
			}
			{
				p.SetState(301)
				p.Eos()
			}


			p.SetState(307)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(308)
			p.Match(GoParserR_PAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeSpecContext is an interface to support dynamic dispatch.
type ITypeSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AliasDecl() IAliasDeclContext
	TypeDef() ITypeDefContext

	// IsTypeSpecContext differentiates from other interfaces.
	IsTypeSpecContext()
}

type TypeSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSpecContext() *TypeSpecContext {
	var p = new(TypeSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeSpec
	return p
}

func InitEmptyTypeSpecContext(p *TypeSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeSpec
}

func (*TypeSpecContext) IsTypeSpecContext() {}

func NewTypeSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSpecContext {
	var p = new(TypeSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeSpec

	return p
}

func (s *TypeSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSpecContext) AliasDecl() IAliasDeclContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasDeclContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasDeclContext)
}

func (s *TypeSpecContext) TypeDef() ITypeDefContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefContext)
}

func (s *TypeSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeSpec(s)
	}
}

func (s *TypeSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeSpec(s)
	}
}

func (s *TypeSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeSpec() (localctx ITypeSpecContext) {
	localctx = NewTypeSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, GoParserRULE_typeSpec)
	p.SetState(313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(311)
			p.AliasDecl()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(312)
			p.TypeDef()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAliasDeclContext is an interface to support dynamic dispatch.
type IAliasDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Type_() IType_Context

	// IsAliasDeclContext differentiates from other interfaces.
	IsAliasDeclContext()
}

type AliasDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasDeclContext() *AliasDeclContext {
	var p = new(AliasDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_aliasDecl
	return p
}

func InitEmptyAliasDeclContext(p *AliasDeclContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_aliasDecl
}

func (*AliasDeclContext) IsAliasDeclContext() {}

func NewAliasDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasDeclContext {
	var p = new(AliasDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_aliasDecl

	return p
}

func (s *AliasDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *AliasDeclContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GoParserASSIGN, 0)
}

func (s *AliasDeclContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *AliasDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AliasDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterAliasDecl(s)
	}
}

func (s *AliasDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitAliasDecl(s)
	}
}

func (s *AliasDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitAliasDecl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) AliasDecl() (localctx IAliasDeclContext) {
	localctx = NewAliasDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, GoParserRULE_aliasDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(315)
		p.Match(GoParserIDENTIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(316)
		p.Match(GoParserASSIGN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(317)
		p.Type_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeDefContext is an interface to support dynamic dispatch.
type ITypeDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Type_() IType_Context
	TypeParameters() ITypeParametersContext

	// IsTypeDefContext differentiates from other interfaces.
	IsTypeDefContext()
}

type TypeDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefContext() *TypeDefContext {
	var p = new(TypeDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeDef
	return p
}

func InitEmptyTypeDefContext(p *TypeDefContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeDef
}

func (*TypeDefContext) IsTypeDefContext() {}

func NewTypeDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefContext {
	var p = new(TypeDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeDef

	return p
}

func (s *TypeDefContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *TypeDefContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeDefContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *TypeDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeDef(s)
	}
}

func (s *TypeDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeDef(s)
	}
}

func (s *TypeDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeDef(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeDef() (localctx ITypeDefContext) {
	localctx = NewTypeDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, GoParserRULE_typeDef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(319)
		p.Match(GoParserIDENTIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(321)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(320)
			p.TypeParameters()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(323)
		p.Type_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_BRACKET() antlr.TerminalNode
	AllTypeParameterDecl() []ITypeParameterDeclContext
	TypeParameterDecl(i int) ITypeParameterDeclContext
	R_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeParameters
	return p
}

func InitEmptyTypeParametersContext(p *TypeParametersContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeParameters
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserL_BRACKET, 0)
}

func (s *TypeParametersContext) AllTypeParameterDecl() []ITypeParameterDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterDeclContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterDeclContext); ok {
			tst[i] = t.(ITypeParameterDeclContext)
			i++
		}
	}

	return tst
}

func (s *TypeParametersContext) TypeParameterDecl(i int) ITypeParameterDeclContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterDeclContext)
}

func (s *TypeParametersContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserR_BRACKET, 0)
}

func (s *TypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GoParserCOMMA)
}

func (s *TypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GoParserCOMMA, i)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (s *TypeParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeParameters(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeParameters() (localctx ITypeParametersContext) {
	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, GoParserRULE_typeParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(325)
		p.Match(GoParserL_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(326)
		p.TypeParameterDecl()
	}
	p.SetState(331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoParserCOMMA {
		{
			p.SetState(327)
			p.Match(GoParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(328)
			p.TypeParameterDecl()
		}


		p.SetState(333)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(334)
		p.Match(GoParserR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeParameterDeclContext is an interface to support dynamic dispatch.
type ITypeParameterDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	TypeElement() ITypeElementContext

	// IsTypeParameterDeclContext differentiates from other interfaces.
	IsTypeParameterDeclContext()
}

type TypeParameterDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterDeclContext() *TypeParameterDeclContext {
	var p = new(TypeParameterDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeParameterDecl
	return p
}

func InitEmptyTypeParameterDeclContext(p *TypeParameterDeclContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeParameterDecl
}

func (*TypeParameterDeclContext) IsTypeParameterDeclContext() {}

func NewTypeParameterDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterDeclContext {
	var p = new(TypeParameterDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeParameterDecl

	return p
}

func (s *TypeParameterDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterDeclContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *TypeParameterDeclContext) TypeElement() ITypeElementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeElementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeElementContext)
}

func (s *TypeParameterDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeParameterDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeParameterDecl(s)
	}
}

func (s *TypeParameterDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeParameterDecl(s)
	}
}

func (s *TypeParameterDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeParameterDecl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeParameterDecl() (localctx ITypeParameterDeclContext) {
	localctx = NewTypeParameterDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, GoParserRULE_typeParameterDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(336)
		p.IdentifierList()
	}
	{
		p.SetState(337)
		p.TypeElement()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeElementContext is an interface to support dynamic dispatch.
type ITypeElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeTerm() []ITypeTermContext
	TypeTerm(i int) ITypeTermContext
	AllOR() []antlr.TerminalNode
	OR(i int) antlr.TerminalNode

	// IsTypeElementContext differentiates from other interfaces.
	IsTypeElementContext()
}

type TypeElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeElementContext() *TypeElementContext {
	var p = new(TypeElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeElement
	return p
}

func InitEmptyTypeElementContext(p *TypeElementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeElement
}

func (*TypeElementContext) IsTypeElementContext() {}

func NewTypeElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeElementContext {
	var p = new(TypeElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeElement

	return p
}

func (s *TypeElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeElementContext) AllTypeTerm() []ITypeTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeTermContext); ok {
			len++
		}
	}

	tst := make([]ITypeTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeTermContext); ok {
			tst[i] = t.(ITypeTermContext)
			i++
		}
	}

	return tst
}

func (s *TypeElementContext) TypeTerm(i int) ITypeTermContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTermContext)
}

func (s *TypeElementContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(GoParserOR)
}

func (s *TypeElementContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(GoParserOR, i)
}

func (s *TypeElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeElement(s)
	}
}

func (s *TypeElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeElement(s)
	}
}

func (s *TypeElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeElement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeElement() (localctx ITypeElementContext) {
	localctx = NewTypeElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, GoParserRULE_typeElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(339)
		p.TypeTerm()
	}
	p.SetState(344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoParserOR {
		{
			p.SetState(340)
			p.Match(GoParserOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(341)
			p.TypeTerm()
		}


		p.SetState(346)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeTermContext is an interface to support dynamic dispatch.
type ITypeTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context
	UNDERLYING() antlr.TerminalNode

	// IsTypeTermContext differentiates from other interfaces.
	IsTypeTermContext()
}

type TypeTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTermContext() *TypeTermContext {
	var p = new(TypeTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeTerm
	return p
}

func InitEmptyTypeTermContext(p *TypeTermContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeTerm
}

func (*TypeTermContext) IsTypeTermContext() {}

func NewTypeTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTermContext {
	var p = new(TypeTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeTerm

	return p
}

func (s *TypeTermContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTermContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeTermContext) UNDERLYING() antlr.TerminalNode {
	return s.GetToken(GoParserUNDERLYING, 0)
}

func (s *TypeTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeTerm(s)
	}
}

func (s *TypeTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeTerm(s)
	}
}

func (s *TypeTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeTerm(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeTerm() (localctx ITypeTermContext) {
	localctx = NewTypeTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, GoParserRULE_typeTerm)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(348)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserUNDERLYING {
		{
			p.SetState(347)
			p.Match(GoParserUNDERLYING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(350)
		p.Type_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionDeclContext is an interface to support dynamic dispatch.
type IFunctionDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNC() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	Signature() ISignatureContext
	TypeParameters() ITypeParametersContext
	Block() IBlockContext

	// IsFunctionDeclContext differentiates from other interfaces.
	IsFunctionDeclContext()
}

type FunctionDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclContext() *FunctionDeclContext {
	var p = new(FunctionDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_functionDecl
	return p
}

func InitEmptyFunctionDeclContext(p *FunctionDeclContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_functionDecl
}

func (*FunctionDeclContext) IsFunctionDeclContext() {}

func NewFunctionDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclContext {
	var p = new(FunctionDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_functionDecl

	return p
}

func (s *FunctionDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclContext) FUNC() antlr.TerminalNode {
	return s.GetToken(GoParserFUNC, 0)
}

func (s *FunctionDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *FunctionDeclContext) Signature() ISignatureContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignatureContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignatureContext)
}

func (s *FunctionDeclContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *FunctionDeclContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterFunctionDecl(s)
	}
}

func (s *FunctionDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitFunctionDecl(s)
	}
}

func (s *FunctionDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitFunctionDecl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) FunctionDecl() (localctx IFunctionDeclContext) {
	localctx = NewFunctionDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, GoParserRULE_functionDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(352)
		p.Match(GoParserFUNC)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(353)
		p.Match(GoParserIDENTIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserL_BRACKET {
		{
			p.SetState(354)
			p.TypeParameters()
		}

	}
	{
		p.SetState(357)
		p.Signature()
	}
	p.SetState(359)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserL_CURLY {
		{
			p.SetState(358)
			p.Block()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMethodDeclContext is an interface to support dynamic dispatch.
type IMethodDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNC() antlr.TerminalNode
	Receiver() IReceiverContext
	IDENTIFIER() antlr.TerminalNode
	Signature() ISignatureContext
	Block() IBlockContext

	// IsMethodDeclContext differentiates from other interfaces.
	IsMethodDeclContext()
}

type MethodDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclContext() *MethodDeclContext {
	var p = new(MethodDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_methodDecl
	return p
}

func InitEmptyMethodDeclContext(p *MethodDeclContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_methodDecl
}

func (*MethodDeclContext) IsMethodDeclContext() {}

func NewMethodDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclContext {
	var p = new(MethodDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_methodDecl

	return p
}

func (s *MethodDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclContext) FUNC() antlr.TerminalNode {
	return s.GetToken(GoParserFUNC, 0)
}

func (s *MethodDeclContext) Receiver() IReceiverContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverContext)
}

func (s *MethodDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *MethodDeclContext) Signature() ISignatureContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignatureContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignatureContext)
}

func (s *MethodDeclContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MethodDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MethodDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterMethodDecl(s)
	}
}

func (s *MethodDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitMethodDecl(s)
	}
}

func (s *MethodDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitMethodDecl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) MethodDecl() (localctx IMethodDeclContext) {
	localctx = NewMethodDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, GoParserRULE_methodDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(361)
		p.Match(GoParserFUNC)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(362)
		p.Receiver()
	}
	{
		p.SetState(363)
		p.Match(GoParserIDENTIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(364)
		p.Signature()
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserL_CURLY {
		{
			p.SetState(365)
			p.Block()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReceiverContext is an interface to support dynamic dispatch.
type IReceiverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parameters() IParametersContext

	// IsReceiverContext differentiates from other interfaces.
	IsReceiverContext()
}

type ReceiverContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverContext() *ReceiverContext {
	var p = new(ReceiverContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_receiver
	return p
}

func InitEmptyReceiverContext(p *ReceiverContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_receiver
}

func (*ReceiverContext) IsReceiverContext() {}

func NewReceiverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverContext {
	var p = new(ReceiverContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_receiver

	return p
}

func (s *ReceiverContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverContext) Parameters() IParametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *ReceiverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReceiverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterReceiver(s)
	}
}

func (s *ReceiverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitReceiver(s)
	}
}

func (s *ReceiverContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitReceiver(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Receiver() (localctx IReceiverContext) {
	localctx = NewReceiverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, GoParserRULE_receiver)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(368)
		p.Parameters()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IVarDeclContext is an interface to support dynamic dispatch.
type IVarDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	AllVarSpec() []IVarSpecContext
	VarSpec(i int) IVarSpecContext
	L_PAREN() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	AllEos() []IEosContext
	Eos(i int) IEosContext

	// IsVarDeclContext differentiates from other interfaces.
	IsVarDeclContext()
}

type VarDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarDeclContext() *VarDeclContext {
	var p = new(VarDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_varDecl
	return p
}

func InitEmptyVarDeclContext(p *VarDeclContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_varDecl
}

func (*VarDeclContext) IsVarDeclContext() {}

func NewVarDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarDeclContext {
	var p = new(VarDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_varDecl

	return p
}

func (s *VarDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *VarDeclContext) VAR() antlr.TerminalNode {
	return s.GetToken(GoParserVAR, 0)
}

func (s *VarDeclContext) AllVarSpec() []IVarSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVarSpecContext); ok {
			len++
		}
	}

	tst := make([]IVarSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVarSpecContext); ok {
			tst[i] = t.(IVarSpecContext)
			i++
		}
	}

	return tst
}

func (s *VarDeclContext) VarSpec(i int) IVarSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarSpecContext)
}

func (s *VarDeclContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserL_PAREN, 0)
}

func (s *VarDeclContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserR_PAREN, 0)
}

func (s *VarDeclContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *VarDeclContext) Eos(i int) IEosContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *VarDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VarDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterVarDecl(s)
	}
}

func (s *VarDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitVarDecl(s)
	}
}

func (s *VarDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitVarDecl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) VarDecl() (localctx IVarDeclContext) {
	localctx = NewVarDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, GoParserRULE_varDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(370)
		p.Match(GoParserVAR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserIDENTIFIER:
		{
			p.SetState(371)
			p.VarSpec()
		}


	case GoParserL_PAREN:
		{
			p.SetState(372)
			p.Match(GoParserL_PAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == GoParserIDENTIFIER {
			{
				p.SetState(373)
				p.VarSpec()
			}
			{
				p.SetState(374)
				p.Eos()
			}


			p.SetState(380)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(381)
			p.Match(GoParserR_PAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IVarSpecContext is an interface to support dynamic dispatch.
type IVarSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	Type_() IType_Context
	ASSIGN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsVarSpecContext differentiates from other interfaces.
	IsVarSpecContext()
}

type VarSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarSpecContext() *VarSpecContext {
	var p = new(VarSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_varSpec
	return p
}

func InitEmptyVarSpecContext(p *VarSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_varSpec
}

func (*VarSpecContext) IsVarSpecContext() {}

func NewVarSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarSpecContext {
	var p = new(VarSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_varSpec

	return p
}

func (s *VarSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *VarSpecContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *VarSpecContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *VarSpecContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GoParserASSIGN, 0)
}

func (s *VarSpecContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *VarSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VarSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterVarSpec(s)
	}
}

func (s *VarSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitVarSpec(s)
	}
}

func (s *VarSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitVarSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) VarSpec() (localctx IVarSpecContext) {
	localctx = NewVarSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, GoParserRULE_varSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(384)
		p.IdentifierList()
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserFUNC, GoParserINTERFACE, GoParserMAP, GoParserSTRUCT, GoParserCHAN, GoParserIDENTIFIER, GoParserL_PAREN, GoParserL_BRACKET, GoParserSTAR, GoParserRECEIVE:
		{
			p.SetState(385)
			p.Type_()
		}
		p.SetState(388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoParserASSIGN {
			{
				p.SetState(386)
				p.Match(GoParserASSIGN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(387)
				p.ExpressionList()
			}

		}


	case GoParserASSIGN:
		{
			p.SetState(390)
			p.Match(GoParserASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(391)
			p.ExpressionList()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_CURLY() antlr.TerminalNode
	R_CURLY() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserL_CURLY, 0)
}

func (s *BlockContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserR_CURLY, 0)
}

func (s *BlockContext) StatementList() IStatementListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, GoParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(394)
		p.Match(GoParserL_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921206115553350) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 67505407) != 0) {
		{
			p.SetState(395)
			p.StatementList()
		}

	}
	{
		p.SetState(398)
		p.Match(GoParserR_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStatementListContext is an interface to support dynamic dispatch.
type IStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllEos() []IEosContext
	Eos(i int) IEosContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllEOS() []antlr.TerminalNode
	EOS(i int) antlr.TerminalNode

	// IsStatementListContext differentiates from other interfaces.
	IsStatementListContext()
}

type StatementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementListContext() *StatementListContext {
	var p = new(StatementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_statementList
	return p
}

func InitEmptyStatementListContext(p *StatementListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_statementList
}

func (*StatementListContext) IsStatementListContext() {}

func NewStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementListContext {
	var p = new(StatementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_statementList

	return p
}

func (s *StatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementListContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementListContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *StatementListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *StatementListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(GoParserSEMI)
}

func (s *StatementListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(GoParserSEMI, i)
}

func (s *StatementListContext) AllEOS() []antlr.TerminalNode {
	return s.GetTokens(GoParserEOS)
}

func (s *StatementListContext) EOS(i int) antlr.TerminalNode {
	return s.GetToken(GoParserEOS, i)
}

func (s *StatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterStatementList(s)
	}
}

func (s *StatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitStatementList(s)
	}
}

func (s *StatementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitStatementList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) StatementList() (localctx IStatementListContext) {
	localctx = NewStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, GoParserRULE_statementList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921206115553350) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 67505407) != 0) {
		p.SetState(406)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
		case 1:
			p.SetState(401)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == GoParserSEMI {
				{
					p.SetState(400)
					p.Match(GoParserSEMI)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}


		case 2:
			p.SetState(404)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == GoParserEOS {
				{
					p.SetState(403)
					p.Match(GoParserEOS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(408)
			p.Statement()
		}
		{
			p.SetState(409)
			p.Eos()
		}


		p.SetState(413)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declaration() IDeclarationContext
	LabeledStmt() ILabeledStmtContext
	SimpleStmt() ISimpleStmtContext
	GoStmt() IGoStmtContext
	ReturnStmt() IReturnStmtContext
	BreakStmt() IBreakStmtContext
	ContinueStmt() IContinueStmtContext
	GotoStmt() IGotoStmtContext
	FallthroughStmt() IFallthroughStmtContext
	Block() IBlockContext
	IfStmt() IIfStmtContext
	SwitchStmt() ISwitchStmtContext
	SelectStmt() ISelectStmtContext
	ForStmt() IForStmtContext
	DeferStmt() IDeferStmtContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *StatementContext) LabeledStmt() ILabeledStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledStmtContext)
}

func (s *StatementContext) SimpleStmt() ISimpleStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStmtContext)
}

func (s *StatementContext) GoStmt() IGoStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGoStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGoStmtContext)
}

func (s *StatementContext) ReturnStmt() IReturnStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStmtContext)
}

func (s *StatementContext) BreakStmt() IBreakStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStmtContext)
}

func (s *StatementContext) ContinueStmt() IContinueStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStmtContext)
}

func (s *StatementContext) GotoStmt() IGotoStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStmtContext)
}

func (s *StatementContext) FallthroughStmt() IFallthroughStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFallthroughStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFallthroughStmtContext)
}

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) IfStmt() IIfStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStmtContext)
}

func (s *StatementContext) SwitchStmt() ISwitchStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStmtContext)
}

func (s *StatementContext) SelectStmt() ISelectStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStmtContext)
}

func (s *StatementContext) ForStmt() IForStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStmtContext)
}

func (s *StatementContext) DeferStmt() IDeferStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeferStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeferStmtContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, GoParserRULE_statement)
	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(415)
			p.Declaration()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(416)
			p.LabeledStmt()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(417)
			p.SimpleStmt()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(418)
			p.GoStmt()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(419)
			p.ReturnStmt()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(420)
			p.BreakStmt()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(421)
			p.ContinueStmt()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(422)
			p.GotoStmt()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(423)
			p.FallthroughStmt()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(424)
			p.Block()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(425)
			p.IfStmt()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(426)
			p.SwitchStmt()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(427)
			p.SelectStmt()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(428)
			p.ForStmt()
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(429)
			p.DeferStmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISimpleStmtContext is an interface to support dynamic dispatch.
type ISimpleStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SendStmt() ISendStmtContext
	IncDecStmt() IIncDecStmtContext
	Assignment() IAssignmentContext
	ExpressionStmt() IExpressionStmtContext
	ShortVarDecl() IShortVarDeclContext

	// IsSimpleStmtContext differentiates from other interfaces.
	IsSimpleStmtContext()
}

type SimpleStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStmtContext() *SimpleStmtContext {
	var p = new(SimpleStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_simpleStmt
	return p
}

func InitEmptySimpleStmtContext(p *SimpleStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_simpleStmt
}

func (*SimpleStmtContext) IsSimpleStmtContext() {}

func NewSimpleStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStmtContext {
	var p = new(SimpleStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_simpleStmt

	return p
}

func (s *SimpleStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStmtContext) SendStmt() ISendStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendStmtContext)
}

func (s *SimpleStmtContext) IncDecStmt() IIncDecStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncDecStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncDecStmtContext)
}

func (s *SimpleStmtContext) Assignment() IAssignmentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *SimpleStmtContext) ExpressionStmt() IExpressionStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStmtContext)
}

func (s *SimpleStmtContext) ShortVarDecl() IShortVarDeclContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShortVarDeclContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShortVarDeclContext)
}

func (s *SimpleStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SimpleStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterSimpleStmt(s)
	}
}

func (s *SimpleStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitSimpleStmt(s)
	}
}

func (s *SimpleStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitSimpleStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) SimpleStmt() (localctx ISimpleStmtContext) {
	localctx = NewSimpleStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, GoParserRULE_simpleStmt)
	p.SetState(437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(432)
			p.SendStmt()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(433)
			p.IncDecStmt()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(434)
			p.Assignment()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(435)
			p.ExpressionStmt()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(436)
			p.ShortVarDecl()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionStmtContext is an interface to support dynamic dispatch.
type IExpressionStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsExpressionStmtContext differentiates from other interfaces.
	IsExpressionStmtContext()
}

type ExpressionStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStmtContext() *ExpressionStmtContext {
	var p = new(ExpressionStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_expressionStmt
	return p
}

func InitEmptyExpressionStmtContext(p *ExpressionStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_expressionStmt
}

func (*ExpressionStmtContext) IsExpressionStmtContext() {}

func NewExpressionStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStmtContext {
	var p = new(ExpressionStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_expressionStmt

	return p
}

func (s *ExpressionStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterExpressionStmt(s)
	}
}

func (s *ExpressionStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitExpressionStmt(s)
	}
}

func (s *ExpressionStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitExpressionStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ExpressionStmt() (localctx IExpressionStmtContext) {
	localctx = NewExpressionStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, GoParserRULE_expressionStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(439)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISendStmtContext is an interface to support dynamic dispatch.
type ISendStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetChannel returns the channel rule contexts.
	GetChannel() IExpressionContext


	// SetChannel sets the channel rule contexts.
	SetChannel(IExpressionContext)


	// Getter signatures
	RECEIVE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsSendStmtContext differentiates from other interfaces.
	IsSendStmtContext()
}

type SendStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	channel IExpressionContext 
}

func NewEmptySendStmtContext() *SendStmtContext {
	var p = new(SendStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_sendStmt
	return p
}

func InitEmptySendStmtContext(p *SendStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_sendStmt
}

func (*SendStmtContext) IsSendStmtContext() {}

func NewSendStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendStmtContext {
	var p = new(SendStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_sendStmt

	return p
}

func (s *SendStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SendStmtContext) GetChannel() IExpressionContext { return s.channel }


func (s *SendStmtContext) SetChannel(v IExpressionContext) { s.channel = v }


func (s *SendStmtContext) RECEIVE() antlr.TerminalNode {
	return s.GetToken(GoParserRECEIVE, 0)
}

func (s *SendStmtContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SendStmtContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SendStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SendStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterSendStmt(s)
	}
}

func (s *SendStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitSendStmt(s)
	}
}

func (s *SendStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitSendStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) SendStmt() (localctx ISendStmtContext) {
	localctx = NewSendStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, GoParserRULE_sendStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)

		var _x = p.expression(0)

		localctx.(*SendStmtContext).channel = _x
	}
	{
		p.SetState(442)
		p.Match(GoParserRECEIVE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(443)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIncDecStmtContext is an interface to support dynamic dispatch.
type IIncDecStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	PLUS_PLUS() antlr.TerminalNode
	MINUS_MINUS() antlr.TerminalNode

	// IsIncDecStmtContext differentiates from other interfaces.
	IsIncDecStmtContext()
}

type IncDecStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncDecStmtContext() *IncDecStmtContext {
	var p = new(IncDecStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_incDecStmt
	return p
}

func InitEmptyIncDecStmtContext(p *IncDecStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_incDecStmt
}

func (*IncDecStmtContext) IsIncDecStmtContext() {}

func NewIncDecStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncDecStmtContext {
	var p = new(IncDecStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_incDecStmt

	return p
}

func (s *IncDecStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IncDecStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IncDecStmtContext) PLUS_PLUS() antlr.TerminalNode {
	return s.GetToken(GoParserPLUS_PLUS, 0)
}

func (s *IncDecStmtContext) MINUS_MINUS() antlr.TerminalNode {
	return s.GetToken(GoParserMINUS_MINUS, 0)
}

func (s *IncDecStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncDecStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IncDecStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterIncDecStmt(s)
	}
}

func (s *IncDecStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitIncDecStmt(s)
	}
}

func (s *IncDecStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitIncDecStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) IncDecStmt() (localctx IIncDecStmtContext) {
	localctx = NewIncDecStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, GoParserRULE_incDecStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(445)
		p.expression(0)
	}
	{
		p.SetState(446)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoParserPLUS_PLUS || _la == GoParserMINUS_MINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpressionList() []IExpressionListContext
	ExpressionList(i int) IExpressionListContext
	Assign_op() IAssign_opContext

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_assignment
	return p
}

func InitEmptyAssignmentContext(p *AssignmentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_assignment
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) AllExpressionList() []IExpressionListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionListContext); ok {
			len++
		}
	}

	tst := make([]IExpressionListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionListContext); ok {
			tst[i] = t.(IExpressionListContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentContext) ExpressionList(i int) IExpressionListContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *AssignmentContext) Assign_op() IAssign_opContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssign_opContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssign_opContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (s *AssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, GoParserRULE_assignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(448)
		p.ExpressionList()
	}
	{
		p.SetState(449)
		p.Assign_op()
	}
	{
		p.SetState(450)
		p.ExpressionList()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAssign_opContext is an interface to support dynamic dispatch.
type IAssign_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	OR() antlr.TerminalNode
	CARET() antlr.TerminalNode
	STAR() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	LSHIFT() antlr.TerminalNode
	RSHIFT() antlr.TerminalNode
	AMPERSAND() antlr.TerminalNode
	BIT_CLEAR() antlr.TerminalNode

	// IsAssign_opContext differentiates from other interfaces.
	IsAssign_opContext()
}

type Assign_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssign_opContext() *Assign_opContext {
	var p = new(Assign_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_assign_op
	return p
}

func InitEmptyAssign_opContext(p *Assign_opContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_assign_op
}

func (*Assign_opContext) IsAssign_opContext() {}

func NewAssign_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assign_opContext {
	var p = new(Assign_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_assign_op

	return p
}

func (s *Assign_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Assign_opContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GoParserASSIGN, 0)
}

func (s *Assign_opContext) PLUS() antlr.TerminalNode {
	return s.GetToken(GoParserPLUS, 0)
}

func (s *Assign_opContext) MINUS() antlr.TerminalNode {
	return s.GetToken(GoParserMINUS, 0)
}

func (s *Assign_opContext) OR() antlr.TerminalNode {
	return s.GetToken(GoParserOR, 0)
}

func (s *Assign_opContext) CARET() antlr.TerminalNode {
	return s.GetToken(GoParserCARET, 0)
}

func (s *Assign_opContext) STAR() antlr.TerminalNode {
	return s.GetToken(GoParserSTAR, 0)
}

func (s *Assign_opContext) DIV() antlr.TerminalNode {
	return s.GetToken(GoParserDIV, 0)
}

func (s *Assign_opContext) MOD() antlr.TerminalNode {
	return s.GetToken(GoParserMOD, 0)
}

func (s *Assign_opContext) LSHIFT() antlr.TerminalNode {
	return s.GetToken(GoParserLSHIFT, 0)
}

func (s *Assign_opContext) RSHIFT() antlr.TerminalNode {
	return s.GetToken(GoParserRSHIFT, 0)
}

func (s *Assign_opContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(GoParserAMPERSAND, 0)
}

func (s *Assign_opContext) BIT_CLEAR() antlr.TerminalNode {
	return s.GetToken(GoParserBIT_CLEAR, 0)
}

func (s *Assign_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assign_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assign_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterAssign_op(s)
	}
}

func (s *Assign_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitAssign_op(s)
	}
}

func (s *Assign_opContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitAssign_op(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Assign_op() (localctx IAssign_opContext) {
	localctx = NewAssign_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, GoParserRULE_assign_op)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 53)) & ^0x3f) == 0 && ((int64(1) << (_la - 53)) & 7999) != 0) {
		{
			p.SetState(452)
			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 53)) & ^0x3f) == 0 && ((int64(1) << (_la - 53)) & 7999) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(455)
		p.Match(GoParserASSIGN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShortVarDeclContext is an interface to support dynamic dispatch.
type IShortVarDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	DECLARE_ASSIGN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsShortVarDeclContext differentiates from other interfaces.
	IsShortVarDeclContext()
}

type ShortVarDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShortVarDeclContext() *ShortVarDeclContext {
	var p = new(ShortVarDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_shortVarDecl
	return p
}

func InitEmptyShortVarDeclContext(p *ShortVarDeclContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_shortVarDecl
}

func (*ShortVarDeclContext) IsShortVarDeclContext() {}

func NewShortVarDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShortVarDeclContext {
	var p = new(ShortVarDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_shortVarDecl

	return p
}

func (s *ShortVarDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ShortVarDeclContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ShortVarDeclContext) DECLARE_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GoParserDECLARE_ASSIGN, 0)
}

func (s *ShortVarDeclContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ShortVarDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortVarDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShortVarDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterShortVarDecl(s)
	}
}

func (s *ShortVarDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitShortVarDecl(s)
	}
}

func (s *ShortVarDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitShortVarDecl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ShortVarDecl() (localctx IShortVarDeclContext) {
	localctx = NewShortVarDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, GoParserRULE_shortVarDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.IdentifierList()
	}
	{
		p.SetState(458)
		p.Match(GoParserDECLARE_ASSIGN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(459)
		p.ExpressionList()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILabeledStmtContext is an interface to support dynamic dispatch.
type ILabeledStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Statement() IStatementContext

	// IsLabeledStmtContext differentiates from other interfaces.
	IsLabeledStmtContext()
}

type LabeledStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledStmtContext() *LabeledStmtContext {
	var p = new(LabeledStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_labeledStmt
	return p
}

func InitEmptyLabeledStmtContext(p *LabeledStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_labeledStmt
}

func (*LabeledStmtContext) IsLabeledStmtContext() {}

func NewLabeledStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledStmtContext {
	var p = new(LabeledStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_labeledStmt

	return p
}

func (s *LabeledStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledStmtContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *LabeledStmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(GoParserCOLON, 0)
}

func (s *LabeledStmtContext) Statement() IStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabeledStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LabeledStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterLabeledStmt(s)
	}
}

func (s *LabeledStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitLabeledStmt(s)
	}
}

func (s *LabeledStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitLabeledStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) LabeledStmt() (localctx ILabeledStmtContext) {
	localctx = NewLabeledStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, GoParserRULE_labeledStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(461)
		p.Match(GoParserIDENTIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(462)
		p.Match(GoParserCOLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921480993460294) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
		{
			p.SetState(463)
			p.Statement()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReturnStmtContext is an interface to support dynamic dispatch.
type IReturnStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsReturnStmtContext differentiates from other interfaces.
	IsReturnStmtContext()
}

type ReturnStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStmtContext() *ReturnStmtContext {
	var p = new(ReturnStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_returnStmt
	return p
}

func InitEmptyReturnStmtContext(p *ReturnStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_returnStmt
}

func (*ReturnStmtContext) IsReturnStmtContext() {}

func NewReturnStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStmtContext {
	var p = new(ReturnStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_returnStmt

	return p
}

func (s *ReturnStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(GoParserRETURN, 0)
}

func (s *ReturnStmtContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ReturnStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReturnStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterReturnStmt(s)
	}
}

func (s *ReturnStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitReturnStmt(s)
	}
}

func (s *ReturnStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitReturnStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ReturnStmt() (localctx IReturnStmtContext) {
	localctx = NewReturnStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, GoParserRULE_returnStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(466)
		p.Match(GoParserRETURN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(468)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921485346599400) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
		{
			p.SetState(467)
			p.ExpressionList()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBreakStmtContext is an interface to support dynamic dispatch.
type IBreakStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsBreakStmtContext differentiates from other interfaces.
	IsBreakStmtContext()
}

type BreakStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStmtContext() *BreakStmtContext {
	var p = new(BreakStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_breakStmt
	return p
}

func InitEmptyBreakStmtContext(p *BreakStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_breakStmt
}

func (*BreakStmtContext) IsBreakStmtContext() {}

func NewBreakStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStmtContext {
	var p = new(BreakStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_breakStmt

	return p
}

func (s *BreakStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(GoParserBREAK, 0)
}

func (s *BreakStmtContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *BreakStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BreakStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterBreakStmt(s)
	}
}

func (s *BreakStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitBreakStmt(s)
	}
}

func (s *BreakStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitBreakStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) BreakStmt() (localctx IBreakStmtContext) {
	localctx = NewBreakStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, GoParserRULE_breakStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(470)
		p.Match(GoParserBREAK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserIDENTIFIER {
		{
			p.SetState(471)
			p.Match(GoParserIDENTIFIER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IContinueStmtContext is an interface to support dynamic dispatch.
type IContinueStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsContinueStmtContext differentiates from other interfaces.
	IsContinueStmtContext()
}

type ContinueStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStmtContext() *ContinueStmtContext {
	var p = new(ContinueStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_continueStmt
	return p
}

func InitEmptyContinueStmtContext(p *ContinueStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_continueStmt
}

func (*ContinueStmtContext) IsContinueStmtContext() {}

func NewContinueStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStmtContext {
	var p = new(ContinueStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_continueStmt

	return p
}

func (s *ContinueStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(GoParserCONTINUE, 0)
}

func (s *ContinueStmtContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *ContinueStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ContinueStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterContinueStmt(s)
	}
}

func (s *ContinueStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitContinueStmt(s)
	}
}

func (s *ContinueStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitContinueStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ContinueStmt() (localctx IContinueStmtContext) {
	localctx = NewContinueStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, GoParserRULE_continueStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(474)
		p.Match(GoParserCONTINUE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserIDENTIFIER {
		{
			p.SetState(475)
			p.Match(GoParserIDENTIFIER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGotoStmtContext is an interface to support dynamic dispatch.
type IGotoStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GOTO() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsGotoStmtContext differentiates from other interfaces.
	IsGotoStmtContext()
}

type GotoStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStmtContext() *GotoStmtContext {
	var p = new(GotoStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_gotoStmt
	return p
}

func InitEmptyGotoStmtContext(p *GotoStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_gotoStmt
}

func (*GotoStmtContext) IsGotoStmtContext() {}

func NewGotoStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStmtContext {
	var p = new(GotoStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_gotoStmt

	return p
}

func (s *GotoStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStmtContext) GOTO() antlr.TerminalNode {
	return s.GetToken(GoParserGOTO, 0)
}

func (s *GotoStmtContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *GotoStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GotoStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterGotoStmt(s)
	}
}

func (s *GotoStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitGotoStmt(s)
	}
}

func (s *GotoStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitGotoStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) GotoStmt() (localctx IGotoStmtContext) {
	localctx = NewGotoStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, GoParserRULE_gotoStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(478)
		p.Match(GoParserGOTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(479)
		p.Match(GoParserIDENTIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFallthroughStmtContext is an interface to support dynamic dispatch.
type IFallthroughStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FALLTHROUGH() antlr.TerminalNode

	// IsFallthroughStmtContext differentiates from other interfaces.
	IsFallthroughStmtContext()
}

type FallthroughStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFallthroughStmtContext() *FallthroughStmtContext {
	var p = new(FallthroughStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_fallthroughStmt
	return p
}

func InitEmptyFallthroughStmtContext(p *FallthroughStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_fallthroughStmt
}

func (*FallthroughStmtContext) IsFallthroughStmtContext() {}

func NewFallthroughStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FallthroughStmtContext {
	var p = new(FallthroughStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_fallthroughStmt

	return p
}

func (s *FallthroughStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *FallthroughStmtContext) FALLTHROUGH() antlr.TerminalNode {
	return s.GetToken(GoParserFALLTHROUGH, 0)
}

func (s *FallthroughStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FallthroughStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FallthroughStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterFallthroughStmt(s)
	}
}

func (s *FallthroughStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitFallthroughStmt(s)
	}
}

func (s *FallthroughStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitFallthroughStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) FallthroughStmt() (localctx IFallthroughStmtContext) {
	localctx = NewFallthroughStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, GoParserRULE_fallthroughStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(481)
		p.Match(GoParserFALLTHROUGH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeferStmtContext is an interface to support dynamic dispatch.
type IDeferStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFER() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDeferStmtContext differentiates from other interfaces.
	IsDeferStmtContext()
}

type DeferStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferStmtContext() *DeferStmtContext {
	var p = new(DeferStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_deferStmt
	return p
}

func InitEmptyDeferStmtContext(p *DeferStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_deferStmt
}

func (*DeferStmtContext) IsDeferStmtContext() {}

func NewDeferStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeferStmtContext {
	var p = new(DeferStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_deferStmt

	return p
}

func (s *DeferStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DeferStmtContext) DEFER() antlr.TerminalNode {
	return s.GetToken(GoParserDEFER, 0)
}

func (s *DeferStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeferStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeferStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeferStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterDeferStmt(s)
	}
}

func (s *DeferStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitDeferStmt(s)
	}
}

func (s *DeferStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitDeferStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) DeferStmt() (localctx IDeferStmtContext) {
	localctx = NewDeferStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, GoParserRULE_deferStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(483)
		p.Match(GoParserDEFER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(484)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIfStmtContext is an interface to support dynamic dispatch.
type IIfStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	AllBlock() []IBlockContext
	Block(i int) IBlockContext
	Expression() IExpressionContext
	Eos() IEosContext
	SimpleStmt() ISimpleStmtContext
	ELSE() antlr.TerminalNode
	IfStmt() IIfStmtContext

	// IsIfStmtContext differentiates from other interfaces.
	IsIfStmtContext()
}

type IfStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStmtContext() *IfStmtContext {
	var p = new(IfStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_ifStmt
	return p
}

func InitEmptyIfStmtContext(p *IfStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_ifStmt
}

func (*IfStmtContext) IsIfStmtContext() {}

func NewIfStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStmtContext {
	var p = new(IfStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_ifStmt

	return p
}

func (s *IfStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(GoParserIF, 0)
}

func (s *IfStmtContext) AllBlock() []IBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockContext); ok {
			len++
		}
	}

	tst := make([]IBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockContext); ok {
			tst[i] = t.(IBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfStmtContext) Block(i int) IBlockContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *IfStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStmtContext) Eos() IEosContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *IfStmtContext) SimpleStmt() ISimpleStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStmtContext)
}

func (s *IfStmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(GoParserELSE, 0)
}

func (s *IfStmtContext) IfStmt() IIfStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStmtContext)
}

func (s *IfStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IfStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterIfStmt(s)
	}
}

func (s *IfStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitIfStmt(s)
	}
}

func (s *IfStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitIfStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) IfStmt() (localctx IIfStmtContext) {
	localctx = NewIfStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, GoParserRULE_ifStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(486)
		p.Match(GoParserIF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(487)
			p.expression(0)
		}


	case 2:
		{
			p.SetState(488)
			p.Eos()
		}
		{
			p.SetState(489)
			p.expression(0)
		}


	case 3:
		{
			p.SetState(491)
			p.SimpleStmt()
		}
		{
			p.SetState(492)
			p.Eos()
		}
		{
			p.SetState(493)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(497)
		p.Block()
	}
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserELSE {
		{
			p.SetState(498)
			p.Match(GoParserELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(501)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case GoParserIF:
			{
				p.SetState(499)
				p.IfStmt()
			}


		case GoParserL_CURLY:
			{
				p.SetState(500)
				p.Block()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISwitchStmtContext is an interface to support dynamic dispatch.
type ISwitchStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExprSwitchStmt() IExprSwitchStmtContext
	TypeSwitchStmt() ITypeSwitchStmtContext

	// IsSwitchStmtContext differentiates from other interfaces.
	IsSwitchStmtContext()
}

type SwitchStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStmtContext() *SwitchStmtContext {
	var p = new(SwitchStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_switchStmt
	return p
}

func InitEmptySwitchStmtContext(p *SwitchStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_switchStmt
}

func (*SwitchStmtContext) IsSwitchStmtContext() {}

func NewSwitchStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStmtContext {
	var p = new(SwitchStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_switchStmt

	return p
}

func (s *SwitchStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStmtContext) ExprSwitchStmt() IExprSwitchStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSwitchStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSwitchStmtContext)
}

func (s *SwitchStmtContext) TypeSwitchStmt() ITypeSwitchStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSwitchStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSwitchStmtContext)
}

func (s *SwitchStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SwitchStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterSwitchStmt(s)
	}
}

func (s *SwitchStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitSwitchStmt(s)
	}
}

func (s *SwitchStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitSwitchStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) SwitchStmt() (localctx ISwitchStmtContext) {
	localctx = NewSwitchStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, GoParserRULE_switchStmt)
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(505)
			p.ExprSwitchStmt()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(506)
			p.TypeSwitchStmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExprSwitchStmtContext is an interface to support dynamic dispatch.
type IExprSwitchStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWITCH() antlr.TerminalNode
	L_CURLY() antlr.TerminalNode
	R_CURLY() antlr.TerminalNode
	Eos() IEosContext
	AllExprCaseClause() []IExprCaseClauseContext
	ExprCaseClause(i int) IExprCaseClauseContext
	Expression() IExpressionContext
	SimpleStmt() ISimpleStmtContext

	// IsExprSwitchStmtContext differentiates from other interfaces.
	IsExprSwitchStmtContext()
}

type ExprSwitchStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprSwitchStmtContext() *ExprSwitchStmtContext {
	var p = new(ExprSwitchStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_exprSwitchStmt
	return p
}

func InitEmptyExprSwitchStmtContext(p *ExprSwitchStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_exprSwitchStmt
}

func (*ExprSwitchStmtContext) IsExprSwitchStmtContext() {}

func NewExprSwitchStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprSwitchStmtContext {
	var p = new(ExprSwitchStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_exprSwitchStmt

	return p
}

func (s *ExprSwitchStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprSwitchStmtContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(GoParserSWITCH, 0)
}

func (s *ExprSwitchStmtContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserL_CURLY, 0)
}

func (s *ExprSwitchStmtContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserR_CURLY, 0)
}

func (s *ExprSwitchStmtContext) Eos() IEosContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExprSwitchStmtContext) AllExprCaseClause() []IExprCaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprCaseClauseContext); ok {
			len++
		}
	}

	tst := make([]IExprCaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprCaseClauseContext); ok {
			tst[i] = t.(IExprCaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *ExprSwitchStmtContext) ExprCaseClause(i int) IExprCaseClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprCaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprCaseClauseContext)
}

func (s *ExprSwitchStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExprSwitchStmtContext) SimpleStmt() ISimpleStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStmtContext)
}

func (s *ExprSwitchStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprSwitchStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExprSwitchStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterExprSwitchStmt(s)
	}
}

func (s *ExprSwitchStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitExprSwitchStmt(s)
	}
}

func (s *ExprSwitchStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitExprSwitchStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ExprSwitchStmt() (localctx IExprSwitchStmtContext) {
	localctx = NewExprSwitchStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, GoParserRULE_exprSwitchStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(509)
		p.Match(GoParserSWITCH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.SetState(511)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921485346599400) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
			{
				p.SetState(510)
				p.expression(0)
			}

		}


	case 2:
		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921485346599400) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
			{
				p.SetState(513)
				p.SimpleStmt()
			}

		}
		{
			p.SetState(516)
			p.Eos()
		}
		p.SetState(518)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921485346599400) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
			{
				p.SetState(517)
				p.expression(0)
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(522)
		p.Match(GoParserL_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoParserDEFAULT || _la == GoParserCASE {
		{
			p.SetState(523)
			p.ExprCaseClause()
		}


		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(529)
		p.Match(GoParserR_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExprCaseClauseContext is an interface to support dynamic dispatch.
type IExprCaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExprSwitchCase() IExprSwitchCaseContext
	COLON() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsExprCaseClauseContext differentiates from other interfaces.
	IsExprCaseClauseContext()
}

type ExprCaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprCaseClauseContext() *ExprCaseClauseContext {
	var p = new(ExprCaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_exprCaseClause
	return p
}

func InitEmptyExprCaseClauseContext(p *ExprCaseClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_exprCaseClause
}

func (*ExprCaseClauseContext) IsExprCaseClauseContext() {}

func NewExprCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprCaseClauseContext {
	var p = new(ExprCaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_exprCaseClause

	return p
}

func (s *ExprCaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprCaseClauseContext) ExprSwitchCase() IExprSwitchCaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSwitchCaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSwitchCaseContext)
}

func (s *ExprCaseClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(GoParserCOLON, 0)
}

func (s *ExprCaseClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *ExprCaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprCaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExprCaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterExprCaseClause(s)
	}
}

func (s *ExprCaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitExprCaseClause(s)
	}
}

func (s *ExprCaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitExprCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ExprCaseClause() (localctx IExprCaseClauseContext) {
	localctx = NewExprCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, GoParserRULE_exprCaseClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(531)
		p.ExprSwitchCase()
	}
	{
		p.SetState(532)
		p.Match(GoParserCOLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921206115553350) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 67505407) != 0) {
		{
			p.SetState(533)
			p.StatementList()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExprSwitchCaseContext is an interface to support dynamic dispatch.
type IExprSwitchCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	DEFAULT() antlr.TerminalNode

	// IsExprSwitchCaseContext differentiates from other interfaces.
	IsExprSwitchCaseContext()
}

type ExprSwitchCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprSwitchCaseContext() *ExprSwitchCaseContext {
	var p = new(ExprSwitchCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_exprSwitchCase
	return p
}

func InitEmptyExprSwitchCaseContext(p *ExprSwitchCaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_exprSwitchCase
}

func (*ExprSwitchCaseContext) IsExprSwitchCaseContext() {}

func NewExprSwitchCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprSwitchCaseContext {
	var p = new(ExprSwitchCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_exprSwitchCase

	return p
}

func (s *ExprSwitchCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprSwitchCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(GoParserCASE, 0)
}

func (s *ExprSwitchCaseContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ExprSwitchCaseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GoParserDEFAULT, 0)
}

func (s *ExprSwitchCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprSwitchCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExprSwitchCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterExprSwitchCase(s)
	}
}

func (s *ExprSwitchCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitExprSwitchCase(s)
	}
}

func (s *ExprSwitchCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitExprSwitchCase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ExprSwitchCase() (localctx IExprSwitchCaseContext) {
	localctx = NewExprSwitchCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, GoParserRULE_exprSwitchCase)
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(536)
			p.Match(GoParserCASE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(537)
			p.ExpressionList()
		}


	case GoParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(538)
			p.Match(GoParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeSwitchStmtContext is an interface to support dynamic dispatch.
type ITypeSwitchStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWITCH() antlr.TerminalNode
	L_CURLY() antlr.TerminalNode
	R_CURLY() antlr.TerminalNode
	TypeSwitchGuard() ITypeSwitchGuardContext
	Eos() IEosContext
	SimpleStmt() ISimpleStmtContext
	AllTypeCaseClause() []ITypeCaseClauseContext
	TypeCaseClause(i int) ITypeCaseClauseContext

	// IsTypeSwitchStmtContext differentiates from other interfaces.
	IsTypeSwitchStmtContext()
}

type TypeSwitchStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSwitchStmtContext() *TypeSwitchStmtContext {
	var p = new(TypeSwitchStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeSwitchStmt
	return p
}

func InitEmptyTypeSwitchStmtContext(p *TypeSwitchStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeSwitchStmt
}

func (*TypeSwitchStmtContext) IsTypeSwitchStmtContext() {}

func NewTypeSwitchStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSwitchStmtContext {
	var p = new(TypeSwitchStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeSwitchStmt

	return p
}

func (s *TypeSwitchStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSwitchStmtContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(GoParserSWITCH, 0)
}

func (s *TypeSwitchStmtContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserL_CURLY, 0)
}

func (s *TypeSwitchStmtContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserR_CURLY, 0)
}

func (s *TypeSwitchStmtContext) TypeSwitchGuard() ITypeSwitchGuardContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSwitchGuardContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSwitchGuardContext)
}

func (s *TypeSwitchStmtContext) Eos() IEosContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *TypeSwitchStmtContext) SimpleStmt() ISimpleStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStmtContext)
}

func (s *TypeSwitchStmtContext) AllTypeCaseClause() []ITypeCaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeCaseClauseContext); ok {
			len++
		}
	}

	tst := make([]ITypeCaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeCaseClauseContext); ok {
			tst[i] = t.(ITypeCaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *TypeSwitchStmtContext) TypeCaseClause(i int) ITypeCaseClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCaseClauseContext)
}

func (s *TypeSwitchStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSwitchStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeSwitchStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeSwitchStmt(s)
	}
}

func (s *TypeSwitchStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeSwitchStmt(s)
	}
}

func (s *TypeSwitchStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeSwitchStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeSwitchStmt() (localctx ITypeSwitchStmtContext) {
	localctx = NewTypeSwitchStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, GoParserRULE_typeSwitchStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.Match(GoParserSWITCH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(542)
			p.TypeSwitchGuard()
		}


	case 2:
		{
			p.SetState(543)
			p.Eos()
		}
		{
			p.SetState(544)
			p.TypeSwitchGuard()
		}


	case 3:
		{
			p.SetState(546)
			p.SimpleStmt()
		}
		{
			p.SetState(547)
			p.Eos()
		}
		{
			p.SetState(548)
			p.TypeSwitchGuard()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(552)
		p.Match(GoParserL_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoParserDEFAULT || _la == GoParserCASE {
		{
			p.SetState(553)
			p.TypeCaseClause()
		}


		p.SetState(558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(559)
		p.Match(GoParserR_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeSwitchGuardContext is an interface to support dynamic dispatch.
type ITypeSwitchGuardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpr() IPrimaryExprContext
	DOT() antlr.TerminalNode
	L_PAREN() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	DECLARE_ASSIGN() antlr.TerminalNode

	// IsTypeSwitchGuardContext differentiates from other interfaces.
	IsTypeSwitchGuardContext()
}

type TypeSwitchGuardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSwitchGuardContext() *TypeSwitchGuardContext {
	var p = new(TypeSwitchGuardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeSwitchGuard
	return p
}

func InitEmptyTypeSwitchGuardContext(p *TypeSwitchGuardContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeSwitchGuard
}

func (*TypeSwitchGuardContext) IsTypeSwitchGuardContext() {}

func NewTypeSwitchGuardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSwitchGuardContext {
	var p = new(TypeSwitchGuardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeSwitchGuard

	return p
}

func (s *TypeSwitchGuardContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSwitchGuardContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *TypeSwitchGuardContext) DOT() antlr.TerminalNode {
	return s.GetToken(GoParserDOT, 0)
}

func (s *TypeSwitchGuardContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserL_PAREN, 0)
}

func (s *TypeSwitchGuardContext) TYPE() antlr.TerminalNode {
	return s.GetToken(GoParserTYPE, 0)
}

func (s *TypeSwitchGuardContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserR_PAREN, 0)
}

func (s *TypeSwitchGuardContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *TypeSwitchGuardContext) DECLARE_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GoParserDECLARE_ASSIGN, 0)
}

func (s *TypeSwitchGuardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSwitchGuardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeSwitchGuardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeSwitchGuard(s)
	}
}

func (s *TypeSwitchGuardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeSwitchGuard(s)
	}
}

func (s *TypeSwitchGuardContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeSwitchGuard(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeSwitchGuard() (localctx ITypeSwitchGuardContext) {
	localctx = NewTypeSwitchGuardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, GoParserRULE_typeSwitchGuard)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(563)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(561)
			p.Match(GoParserIDENTIFIER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(562)
			p.Match(GoParserDECLARE_ASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(565)
		p.primaryExpr(0)
	}
	{
		p.SetState(566)
		p.Match(GoParserDOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(567)
		p.Match(GoParserL_PAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(568)
		p.Match(GoParserTYPE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(569)
		p.Match(GoParserR_PAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeCaseClauseContext is an interface to support dynamic dispatch.
type ITypeCaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeSwitchCase() ITypeSwitchCaseContext
	COLON() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsTypeCaseClauseContext differentiates from other interfaces.
	IsTypeCaseClauseContext()
}

type TypeCaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeCaseClauseContext() *TypeCaseClauseContext {
	var p = new(TypeCaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeCaseClause
	return p
}

func InitEmptyTypeCaseClauseContext(p *TypeCaseClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeCaseClause
}

func (*TypeCaseClauseContext) IsTypeCaseClauseContext() {}

func NewTypeCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeCaseClauseContext {
	var p = new(TypeCaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeCaseClause

	return p
}

func (s *TypeCaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeCaseClauseContext) TypeSwitchCase() ITypeSwitchCaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSwitchCaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSwitchCaseContext)
}

func (s *TypeCaseClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(GoParserCOLON, 0)
}

func (s *TypeCaseClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *TypeCaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeCaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeCaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeCaseClause(s)
	}
}

func (s *TypeCaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeCaseClause(s)
	}
}

func (s *TypeCaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeCaseClause() (localctx ITypeCaseClauseContext) {
	localctx = NewTypeCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, GoParserRULE_typeCaseClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(571)
		p.TypeSwitchCase()
	}
	{
		p.SetState(572)
		p.Match(GoParserCOLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921206115553350) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 67505407) != 0) {
		{
			p.SetState(573)
			p.StatementList()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeSwitchCaseContext is an interface to support dynamic dispatch.
type ITypeSwitchCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	TypeList() ITypeListContext
	DEFAULT() antlr.TerminalNode

	// IsTypeSwitchCaseContext differentiates from other interfaces.
	IsTypeSwitchCaseContext()
}

type TypeSwitchCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSwitchCaseContext() *TypeSwitchCaseContext {
	var p = new(TypeSwitchCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeSwitchCase
	return p
}

func InitEmptyTypeSwitchCaseContext(p *TypeSwitchCaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeSwitchCase
}

func (*TypeSwitchCaseContext) IsTypeSwitchCaseContext() {}

func NewTypeSwitchCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSwitchCaseContext {
	var p = new(TypeSwitchCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeSwitchCase

	return p
}

func (s *TypeSwitchCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSwitchCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(GoParserCASE, 0)
}

func (s *TypeSwitchCaseContext) TypeList() ITypeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeSwitchCaseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GoParserDEFAULT, 0)
}

func (s *TypeSwitchCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSwitchCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeSwitchCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeSwitchCase(s)
	}
}

func (s *TypeSwitchCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeSwitchCase(s)
	}
}

func (s *TypeSwitchCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeSwitchCase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeSwitchCase() (localctx ITypeSwitchCaseContext) {
	localctx = NewTypeSwitchCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, GoParserRULE_typeSwitchCase)
	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(576)
			p.Match(GoParserCASE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(577)
			p.TypeList()
		}


	case GoParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(578)
			p.Match(GoParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []IType_Context
	Type_(i int) IType_Context
	AllNIL_LIT() []antlr.TerminalNode
	NIL_LIT(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllType_() []IType_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_Context); ok {
			len++
		}
	}

	tst := make([]IType_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_Context); ok {
			tst[i] = t.(IType_Context)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) Type_(i int) IType_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeListContext) AllNIL_LIT() []antlr.TerminalNode {
	return s.GetTokens(GoParserNIL_LIT)
}

func (s *TypeListContext) NIL_LIT(i int) antlr.TerminalNode {
	return s.GetToken(GoParserNIL_LIT, i)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GoParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GoParserCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, GoParserRULE_typeList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(583)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserFUNC, GoParserINTERFACE, GoParserMAP, GoParserSTRUCT, GoParserCHAN, GoParserIDENTIFIER, GoParserL_PAREN, GoParserL_BRACKET, GoParserSTAR, GoParserRECEIVE:
		{
			p.SetState(581)
			p.Type_()
		}


	case GoParserNIL_LIT:
		{
			p.SetState(582)
			p.Match(GoParserNIL_LIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(585)
				p.Match(GoParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(588)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case GoParserFUNC, GoParserINTERFACE, GoParserMAP, GoParserSTRUCT, GoParserCHAN, GoParserIDENTIFIER, GoParserL_PAREN, GoParserL_BRACKET, GoParserSTAR, GoParserRECEIVE:
				{
					p.SetState(586)
					p.Type_()
				}


			case GoParserNIL_LIT:
				{
					p.SetState(587)
					p.Match(GoParserNIL_LIT)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}


		}
		p.SetState(594)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectStmtContext is an interface to support dynamic dispatch.
type ISelectStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	L_CURLY() antlr.TerminalNode
	R_CURLY() antlr.TerminalNode
	AllCommClause() []ICommClauseContext
	CommClause(i int) ICommClauseContext

	// IsSelectStmtContext differentiates from other interfaces.
	IsSelectStmtContext()
}

type SelectStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStmtContext() *SelectStmtContext {
	var p = new(SelectStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_selectStmt
	return p
}

func InitEmptySelectStmtContext(p *SelectStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_selectStmt
}

func (*SelectStmtContext) IsSelectStmtContext() {}

func NewSelectStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStmtContext {
	var p = new(SelectStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_selectStmt

	return p
}

func (s *SelectStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStmtContext) SELECT() antlr.TerminalNode {
	return s.GetToken(GoParserSELECT, 0)
}

func (s *SelectStmtContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserL_CURLY, 0)
}

func (s *SelectStmtContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserR_CURLY, 0)
}

func (s *SelectStmtContext) AllCommClause() []ICommClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommClauseContext); ok {
			len++
		}
	}

	tst := make([]ICommClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommClauseContext); ok {
			tst[i] = t.(ICommClauseContext)
			i++
		}
	}

	return tst
}

func (s *SelectStmtContext) CommClause(i int) ICommClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommClauseContext)
}

func (s *SelectStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterSelectStmt(s)
	}
}

func (s *SelectStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitSelectStmt(s)
	}
}

func (s *SelectStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitSelectStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) SelectStmt() (localctx ISelectStmtContext) {
	localctx = NewSelectStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, GoParserRULE_selectStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(595)
		p.Match(GoParserSELECT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(596)
		p.Match(GoParserL_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoParserDEFAULT || _la == GoParserCASE {
		{
			p.SetState(597)
			p.CommClause()
		}


		p.SetState(602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(603)
		p.Match(GoParserR_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICommClauseContext is an interface to support dynamic dispatch.
type ICommClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CommCase() ICommCaseContext
	COLON() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsCommClauseContext differentiates from other interfaces.
	IsCommClauseContext()
}

type CommClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommClauseContext() *CommClauseContext {
	var p = new(CommClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_commClause
	return p
}

func InitEmptyCommClauseContext(p *CommClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_commClause
}

func (*CommClauseContext) IsCommClauseContext() {}

func NewCommClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommClauseContext {
	var p = new(CommClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_commClause

	return p
}

func (s *CommClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CommClauseContext) CommCase() ICommCaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommCaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommCaseContext)
}

func (s *CommClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(GoParserCOLON, 0)
}

func (s *CommClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *CommClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CommClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterCommClause(s)
	}
}

func (s *CommClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitCommClause(s)
	}
}

func (s *CommClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitCommClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) CommClause() (localctx ICommClauseContext) {
	localctx = NewCommClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, GoParserRULE_commClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(605)
		p.CommCase()
	}
	{
		p.SetState(606)
		p.Match(GoParserCOLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921206115553350) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 67505407) != 0) {
		{
			p.SetState(607)
			p.StatementList()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICommCaseContext is an interface to support dynamic dispatch.
type ICommCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	SendStmt() ISendStmtContext
	RecvStmt() IRecvStmtContext
	DEFAULT() antlr.TerminalNode

	// IsCommCaseContext differentiates from other interfaces.
	IsCommCaseContext()
}

type CommCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommCaseContext() *CommCaseContext {
	var p = new(CommCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_commCase
	return p
}

func InitEmptyCommCaseContext(p *CommCaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_commCase
}

func (*CommCaseContext) IsCommCaseContext() {}

func NewCommCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommCaseContext {
	var p = new(CommCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_commCase

	return p
}

func (s *CommCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CommCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(GoParserCASE, 0)
}

func (s *CommCaseContext) SendStmt() ISendStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendStmtContext)
}

func (s *CommCaseContext) RecvStmt() IRecvStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecvStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecvStmtContext)
}

func (s *CommCaseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GoParserDEFAULT, 0)
}

func (s *CommCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CommCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterCommCase(s)
	}
}

func (s *CommCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitCommCase(s)
	}
}

func (s *CommCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitCommCase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) CommCase() (localctx ICommCaseContext) {
	localctx = NewCommCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, GoParserRULE_commCase)
	p.SetState(616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(610)
			p.Match(GoParserCASE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(613)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(611)
				p.SendStmt()
			}


		case 2:
			{
				p.SetState(612)
				p.RecvStmt()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}


	case GoParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(615)
			p.Match(GoParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRecvStmtContext is an interface to support dynamic dispatch.
type IRecvStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRecvExpr returns the recvExpr rule contexts.
	GetRecvExpr() IExpressionContext


	// SetRecvExpr sets the recvExpr rule contexts.
	SetRecvExpr(IExpressionContext)


	// Getter signatures
	Expression() IExpressionContext
	ExpressionList() IExpressionListContext
	ASSIGN() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	DECLARE_ASSIGN() antlr.TerminalNode

	// IsRecvStmtContext differentiates from other interfaces.
	IsRecvStmtContext()
}

type RecvStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	recvExpr IExpressionContext 
}

func NewEmptyRecvStmtContext() *RecvStmtContext {
	var p = new(RecvStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_recvStmt
	return p
}

func InitEmptyRecvStmtContext(p *RecvStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_recvStmt
}

func (*RecvStmtContext) IsRecvStmtContext() {}

func NewRecvStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecvStmtContext {
	var p = new(RecvStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_recvStmt

	return p
}

func (s *RecvStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RecvStmtContext) GetRecvExpr() IExpressionContext { return s.recvExpr }


func (s *RecvStmtContext) SetRecvExpr(v IExpressionContext) { s.recvExpr = v }


func (s *RecvStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RecvStmtContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RecvStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GoParserASSIGN, 0)
}

func (s *RecvStmtContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RecvStmtContext) DECLARE_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GoParserDECLARE_ASSIGN, 0)
}

func (s *RecvStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecvStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RecvStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterRecvStmt(s)
	}
}

func (s *RecvStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitRecvStmt(s)
	}
}

func (s *RecvStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitRecvStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) RecvStmt() (localctx IRecvStmtContext) {
	localctx = NewRecvStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, GoParserRULE_recvStmt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(624)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(618)
			p.ExpressionList()
		}
		{
			p.SetState(619)
			p.Match(GoParserASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(621)
			p.IdentifierList()
		}
		{
			p.SetState(622)
			p.Match(GoParserDECLARE_ASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(626)

		var _x = p.expression(0)

		localctx.(*RecvStmtContext).recvExpr = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IForStmtContext is an interface to support dynamic dispatch.
type IForStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Block() IBlockContext
	ForClause() IForClauseContext
	Expression() IExpressionContext
	RangeClause() IRangeClauseContext

	// IsForStmtContext differentiates from other interfaces.
	IsForStmtContext()
}

type ForStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStmtContext() *ForStmtContext {
	var p = new(ForStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_forStmt
	return p
}

func InitEmptyForStmtContext(p *ForStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_forStmt
}

func (*ForStmtContext) IsForStmtContext() {}

func NewForStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStmtContext {
	var p = new(ForStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_forStmt

	return p
}

func (s *ForStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(GoParserFOR, 0)
}

func (s *ForStmtContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ForStmtContext) ForClause() IForClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForClauseContext)
}

func (s *ForStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStmtContext) RangeClause() IRangeClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeClauseContext)
}

func (s *ForStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ForStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterForStmt(s)
	}
}

func (s *ForStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitForStmt(s)
	}
}

func (s *ForStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitForStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ForStmt() (localctx IForStmtContext) {
	localctx = NewForStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, GoParserRULE_forStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(628)
		p.Match(GoParserFOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921485346599400) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
			{
				p.SetState(629)
				p.expression(0)
			}

		}


	case 2:
		{
			p.SetState(632)
			p.ForClause()
		}


	case 3:
		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921485346075112) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
			{
				p.SetState(633)
				p.RangeClause()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(638)
		p.Block()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IForClauseContext is an interface to support dynamic dispatch.
type IForClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInitStmt returns the initStmt rule contexts.
	GetInitStmt() ISimpleStmtContext

	// GetPostStmt returns the postStmt rule contexts.
	GetPostStmt() ISimpleStmtContext


	// SetInitStmt sets the initStmt rule contexts.
	SetInitStmt(ISimpleStmtContext)

	// SetPostStmt sets the postStmt rule contexts.
	SetPostStmt(ISimpleStmtContext)


	// Getter signatures
	AllEos() []IEosContext
	Eos(i int) IEosContext
	Expression() IExpressionContext
	AllSimpleStmt() []ISimpleStmtContext
	SimpleStmt(i int) ISimpleStmtContext

	// IsForClauseContext differentiates from other interfaces.
	IsForClauseContext()
}

type ForClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	initStmt ISimpleStmtContext 
	postStmt ISimpleStmtContext 
}

func NewEmptyForClauseContext() *ForClauseContext {
	var p = new(ForClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_forClause
	return p
}

func InitEmptyForClauseContext(p *ForClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_forClause
}

func (*ForClauseContext) IsForClauseContext() {}

func NewForClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForClauseContext {
	var p = new(ForClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_forClause

	return p
}

func (s *ForClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ForClauseContext) GetInitStmt() ISimpleStmtContext { return s.initStmt }

func (s *ForClauseContext) GetPostStmt() ISimpleStmtContext { return s.postStmt }


func (s *ForClauseContext) SetInitStmt(v ISimpleStmtContext) { s.initStmt = v }

func (s *ForClauseContext) SetPostStmt(v ISimpleStmtContext) { s.postStmt = v }


func (s *ForClauseContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ForClauseContext) Eos(i int) IEosContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ForClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForClauseContext) AllSimpleStmt() []ISimpleStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleStmtContext); ok {
			len++
		}
	}

	tst := make([]ISimpleStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleStmtContext); ok {
			tst[i] = t.(ISimpleStmtContext)
			i++
		}
	}

	return tst
}

func (s *ForClauseContext) SimpleStmt(i int) ISimpleStmtContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStmtContext)
}

func (s *ForClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ForClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterForClause(s)
	}
}

func (s *ForClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitForClause(s)
	}
}

func (s *ForClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitForClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ForClause() (localctx IForClauseContext) {
	localctx = NewForClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, GoParserRULE_forClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(641)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921485346599400) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
		{
			p.SetState(640)

			var _x = p.SimpleStmt()


			localctx.(*ForClauseContext).initStmt = _x
		}

	}
	{
		p.SetState(643)
		p.Eos()
	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921485346599400) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
		{
			p.SetState(644)
			p.expression(0)
		}

	}
	{
		p.SetState(647)
		p.Eos()
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921485346599400) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
		{
			p.SetState(648)

			var _x = p.SimpleStmt()


			localctx.(*ForClauseContext).postStmt = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRangeClauseContext is an interface to support dynamic dispatch.
type IRangeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RANGE() antlr.TerminalNode
	Expression() IExpressionContext
	ExpressionList() IExpressionListContext
	ASSIGN() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	DECLARE_ASSIGN() antlr.TerminalNode

	// IsRangeClauseContext differentiates from other interfaces.
	IsRangeClauseContext()
}

type RangeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeClauseContext() *RangeClauseContext {
	var p = new(RangeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_rangeClause
	return p
}

func InitEmptyRangeClauseContext(p *RangeClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_rangeClause
}

func (*RangeClauseContext) IsRangeClauseContext() {}

func NewRangeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeClauseContext {
	var p = new(RangeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_rangeClause

	return p
}

func (s *RangeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeClauseContext) RANGE() antlr.TerminalNode {
	return s.GetToken(GoParserRANGE, 0)
}

func (s *RangeClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RangeClauseContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RangeClauseContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GoParserASSIGN, 0)
}

func (s *RangeClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RangeClauseContext) DECLARE_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GoParserDECLARE_ASSIGN, 0)
}

func (s *RangeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RangeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterRangeClause(s)
	}
}

func (s *RangeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitRangeClause(s)
	}
}

func (s *RangeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitRangeClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) RangeClause() (localctx IRangeClauseContext) {
	localctx = NewRangeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, GoParserRULE_rangeClause)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(657)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(651)
			p.ExpressionList()
		}
		{
			p.SetState(652)
			p.Match(GoParserASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(654)
			p.IdentifierList()
		}
		{
			p.SetState(655)
			p.Match(GoParserDECLARE_ASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(659)
		p.Match(GoParserRANGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(660)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGoStmtContext is an interface to support dynamic dispatch.
type IGoStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GO() antlr.TerminalNode
	Expression() IExpressionContext

	// IsGoStmtContext differentiates from other interfaces.
	IsGoStmtContext()
}

type GoStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoStmtContext() *GoStmtContext {
	var p = new(GoStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_goStmt
	return p
}

func InitEmptyGoStmtContext(p *GoStmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_goStmt
}

func (*GoStmtContext) IsGoStmtContext() {}

func NewGoStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoStmtContext {
	var p = new(GoStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_goStmt

	return p
}

func (s *GoStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GoStmtContext) GO() antlr.TerminalNode {
	return s.GetToken(GoParserGO, 0)
}

func (s *GoStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GoStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GoStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterGoStmt(s)
	}
}

func (s *GoStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitGoStmt(s)
	}
}

func (s *GoStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitGoStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) GoStmt() (localctx IGoStmtContext) {
	localctx = NewGoStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, GoParserRULE_goStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(662)
		p.Match(GoParserGO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(663)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	TypeArgs() ITypeArgsContext
	TypeLit() ITypeLitContext
	L_PAREN() antlr.TerminalNode
	Type_() IType_Context
	R_PAREN() antlr.TerminalNode

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_type_
	return p
}

func InitEmptyType_Context(p *Type_Context)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_type_
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) TypeName() ITypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *Type_Context) TypeArgs() ITypeArgsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgsContext)
}

func (s *Type_Context) TypeLit() ITypeLitContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeLitContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeLitContext)
}

func (s *Type_Context) L_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserL_PAREN, 0)
}

func (s *Type_Context) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *Type_Context) R_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserR_PAREN, 0)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitType_(s)
	}
}

func (s *Type_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitType_(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Type_() (localctx IType_Context) {
	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, GoParserRULE_type_)
	var _la int

	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(665)
			p.TypeName()
		}
		p.SetState(667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoParserL_BRACKET {
			{
				p.SetState(666)
				p.TypeArgs()
			}

		}


	case GoParserFUNC, GoParserINTERFACE, GoParserMAP, GoParserSTRUCT, GoParserCHAN, GoParserL_BRACKET, GoParserSTAR, GoParserRECEIVE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(669)
			p.TypeLit()
		}


	case GoParserL_PAREN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(670)
			p.Match(GoParserL_PAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(671)
			p.Type_()
		}
		{
			p.SetState(672)
			p.Match(GoParserR_PAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeArgsContext is an interface to support dynamic dispatch.
type ITypeArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_BRACKET() antlr.TerminalNode
	TypeList() ITypeListContext
	R_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsTypeArgsContext differentiates from other interfaces.
	IsTypeArgsContext()
}

type TypeArgsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgsContext() *TypeArgsContext {
	var p = new(TypeArgsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeArgs
	return p
}

func InitEmptyTypeArgsContext(p *TypeArgsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeArgs
}

func (*TypeArgsContext) IsTypeArgsContext() {}

func NewTypeArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgsContext {
	var p = new(TypeArgsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeArgs

	return p
}

func (s *TypeArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgsContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserL_BRACKET, 0)
}

func (s *TypeArgsContext) TypeList() ITypeListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeArgsContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserR_BRACKET, 0)
}

func (s *TypeArgsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GoParserCOMMA, 0)
}

func (s *TypeArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeArgs(s)
	}
}

func (s *TypeArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeArgs(s)
	}
}

func (s *TypeArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeArgs(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeArgs() (localctx ITypeArgsContext) {
	localctx = NewTypeArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, GoParserRULE_typeArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		p.Match(GoParserL_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(677)
		p.TypeList()
	}
	p.SetState(679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserCOMMA {
		{
			p.SetState(678)
			p.Match(GoParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(681)
		p.Match(GoParserR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdent() IQualifiedIdentContext
	IDENTIFIER() antlr.TerminalNode

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeName
	return p
}

func InitEmptyTypeNameContext(p *TypeNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeName
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) QualifiedIdent() IQualifiedIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentContext)
}

func (s *TypeNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (s *TypeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeName() (localctx ITypeNameContext) {
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, GoParserRULE_typeName)
	p.SetState(685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(683)
			p.QualifiedIdent()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(684)
			p.Match(GoParserIDENTIFIER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeLitContext is an interface to support dynamic dispatch.
type ITypeLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayType() IArrayTypeContext
	StructType() IStructTypeContext
	PointerType() IPointerTypeContext
	FunctionType() IFunctionTypeContext
	InterfaceType() IInterfaceTypeContext
	SliceType() ISliceTypeContext
	MapType() IMapTypeContext
	ChannelType() IChannelTypeContext

	// IsTypeLitContext differentiates from other interfaces.
	IsTypeLitContext()
}

type TypeLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeLitContext() *TypeLitContext {
	var p = new(TypeLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeLit
	return p
}

func InitEmptyTypeLitContext(p *TypeLitContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeLit
}

func (*TypeLitContext) IsTypeLitContext() {}

func NewTypeLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeLitContext {
	var p = new(TypeLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeLit

	return p
}

func (s *TypeLitContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeLitContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeLitContext) StructType() IStructTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructTypeContext)
}

func (s *TypeLitContext) PointerType() IPointerTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerTypeContext)
}

func (s *TypeLitContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *TypeLitContext) InterfaceType() IInterfaceTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeContext)
}

func (s *TypeLitContext) SliceType() ISliceTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISliceTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISliceTypeContext)
}

func (s *TypeLitContext) MapType() IMapTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *TypeLitContext) ChannelType() IChannelTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelTypeContext)
}

func (s *TypeLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeLit(s)
	}
}

func (s *TypeLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeLit(s)
	}
}

func (s *TypeLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeLit(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeLit() (localctx ITypeLitContext) {
	localctx = NewTypeLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, GoParserRULE_typeLit)
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(687)
			p.ArrayType()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(688)
			p.StructType()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(689)
			p.PointerType()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(690)
			p.FunctionType()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(691)
			p.InterfaceType()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(692)
			p.SliceType()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(693)
			p.MapType()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(694)
			p.ChannelType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_BRACKET() antlr.TerminalNode
	ArrayLength() IArrayLengthContext
	R_BRACKET() antlr.TerminalNode
	ElementType() IElementTypeContext

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserL_BRACKET, 0)
}

func (s *ArrayTypeContext) ArrayLength() IArrayLengthContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLengthContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLengthContext)
}

func (s *ArrayTypeContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserR_BRACKET, 0)
}

func (s *ArrayTypeContext) ElementType() IElementTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTypeContext)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, GoParserRULE_arrayType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(697)
		p.Match(GoParserL_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(698)
		p.ArrayLength()
	}
	{
		p.SetState(699)
		p.Match(GoParserR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(700)
		p.ElementType()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IArrayLengthContext is an interface to support dynamic dispatch.
type IArrayLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsArrayLengthContext differentiates from other interfaces.
	IsArrayLengthContext()
}

type ArrayLengthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLengthContext() *ArrayLengthContext {
	var p = new(ArrayLengthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_arrayLength
	return p
}

func InitEmptyArrayLengthContext(p *ArrayLengthContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_arrayLength
}

func (*ArrayLengthContext) IsArrayLengthContext() {}

func NewArrayLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLengthContext {
	var p = new(ArrayLengthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_arrayLength

	return p
}

func (s *ArrayLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLengthContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArrayLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterArrayLength(s)
	}
}

func (s *ArrayLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitArrayLength(s)
	}
}

func (s *ArrayLengthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitArrayLength(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ArrayLength() (localctx IArrayLengthContext) {
	localctx = NewArrayLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, GoParserRULE_arrayLength)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IElementTypeContext is an interface to support dynamic dispatch.
type IElementTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context

	// IsElementTypeContext differentiates from other interfaces.
	IsElementTypeContext()
}

type ElementTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementTypeContext() *ElementTypeContext {
	var p = new(ElementTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_elementType
	return p
}

func InitEmptyElementTypeContext(p *ElementTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_elementType
}

func (*ElementTypeContext) IsElementTypeContext() {}

func NewElementTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementTypeContext {
	var p = new(ElementTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_elementType

	return p
}

func (s *ElementTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementTypeContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ElementTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElementTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterElementType(s)
	}
}

func (s *ElementTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitElementType(s)
	}
}

func (s *ElementTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitElementType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ElementType() (localctx IElementTypeContext) {
	localctx = NewElementTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, GoParserRULE_elementType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(704)
		p.Type_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPointerTypeContext is an interface to support dynamic dispatch.
type IPointerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Type_() IType_Context

	// IsPointerTypeContext differentiates from other interfaces.
	IsPointerTypeContext()
}

type PointerTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerTypeContext() *PointerTypeContext {
	var p = new(PointerTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_pointerType
	return p
}

func InitEmptyPointerTypeContext(p *PointerTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_pointerType
}

func (*PointerTypeContext) IsPointerTypeContext() {}

func NewPointerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerTypeContext {
	var p = new(PointerTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_pointerType

	return p
}

func (s *PointerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerTypeContext) STAR() antlr.TerminalNode {
	return s.GetToken(GoParserSTAR, 0)
}

func (s *PointerTypeContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *PointerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PointerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterPointerType(s)
	}
}

func (s *PointerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitPointerType(s)
	}
}

func (s *PointerTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitPointerType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) PointerType() (localctx IPointerTypeContext) {
	localctx = NewPointerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, GoParserRULE_pointerType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.Match(GoParserSTAR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(707)
		p.Type_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInterfaceTypeContext is an interface to support dynamic dispatch.
type IInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	L_CURLY() antlr.TerminalNode
	R_CURLY() antlr.TerminalNode
	AllEos() []IEosContext
	Eos(i int) IEosContext
	AllMethodSpec() []IMethodSpecContext
	MethodSpec(i int) IMethodSpecContext
	AllTypeElement() []ITypeElementContext
	TypeElement(i int) ITypeElementContext

	// IsInterfaceTypeContext differentiates from other interfaces.
	IsInterfaceTypeContext()
}

type InterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeContext() *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_interfaceType
	return p
}

func InitEmptyInterfaceTypeContext(p *InterfaceTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_interfaceType
}

func (*InterfaceTypeContext) IsInterfaceTypeContext() {}

func NewInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_interfaceType

	return p
}

func (s *InterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(GoParserINTERFACE, 0)
}

func (s *InterfaceTypeContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserL_CURLY, 0)
}

func (s *InterfaceTypeContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserR_CURLY, 0)
}

func (s *InterfaceTypeContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceTypeContext) Eos(i int) IEosContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *InterfaceTypeContext) AllMethodSpec() []IMethodSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodSpecContext); ok {
			len++
		}
	}

	tst := make([]IMethodSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodSpecContext); ok {
			tst[i] = t.(IMethodSpecContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceTypeContext) MethodSpec(i int) IMethodSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodSpecContext)
}

func (s *InterfaceTypeContext) AllTypeElement() []ITypeElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeElementContext); ok {
			len++
		}
	}

	tst := make([]ITypeElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeElementContext); ok {
			tst[i] = t.(ITypeElementContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceTypeContext) TypeElement(i int) ITypeElementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeElementContext)
}

func (s *InterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) InterfaceType() (localctx IInterfaceTypeContext) {
	localctx = NewInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, GoParserRULE_interfaceType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(709)
		p.Match(GoParserINTERFACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(710)
		p.Match(GoParserL_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64((_la - 3)) & ^0x3f) == 0 && ((int64(1) << (_la - 3)) & -6845471431254343229) != 0) {
		p.SetState(713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(711)
				p.MethodSpec()
			}


		case 2:
			{
				p.SetState(712)
				p.TypeElement()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(715)
			p.Eos()
		}


		p.SetState(721)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(722)
		p.Match(GoParserR_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISliceTypeContext is an interface to support dynamic dispatch.
type ISliceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_BRACKET() antlr.TerminalNode
	R_BRACKET() antlr.TerminalNode
	ElementType() IElementTypeContext

	// IsSliceTypeContext differentiates from other interfaces.
	IsSliceTypeContext()
}

type SliceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySliceTypeContext() *SliceTypeContext {
	var p = new(SliceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_sliceType
	return p
}

func InitEmptySliceTypeContext(p *SliceTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_sliceType
}

func (*SliceTypeContext) IsSliceTypeContext() {}

func NewSliceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceTypeContext {
	var p = new(SliceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_sliceType

	return p
}

func (s *SliceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceTypeContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserL_BRACKET, 0)
}

func (s *SliceTypeContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserR_BRACKET, 0)
}

func (s *SliceTypeContext) ElementType() IElementTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTypeContext)
}

func (s *SliceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SliceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterSliceType(s)
	}
}

func (s *SliceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitSliceType(s)
	}
}

func (s *SliceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitSliceType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) SliceType() (localctx ISliceTypeContext) {
	localctx = NewSliceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, GoParserRULE_sliceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(724)
		p.Match(GoParserL_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(725)
		p.Match(GoParserR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(726)
		p.ElementType()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMapTypeContext is an interface to support dynamic dispatch.
type IMapTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAP() antlr.TerminalNode
	L_BRACKET() antlr.TerminalNode
	Type_() IType_Context
	R_BRACKET() antlr.TerminalNode
	ElementType() IElementTypeContext

	// IsMapTypeContext differentiates from other interfaces.
	IsMapTypeContext()
}

type MapTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapTypeContext() *MapTypeContext {
	var p = new(MapTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_mapType
	return p
}

func InitEmptyMapTypeContext(p *MapTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_mapType
}

func (*MapTypeContext) IsMapTypeContext() {}

func NewMapTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapTypeContext {
	var p = new(MapTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_mapType

	return p
}

func (s *MapTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MapTypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(GoParserMAP, 0)
}

func (s *MapTypeContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserL_BRACKET, 0)
}

func (s *MapTypeContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *MapTypeContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserR_BRACKET, 0)
}

func (s *MapTypeContext) ElementType() IElementTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTypeContext)
}

func (s *MapTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MapTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterMapType(s)
	}
}

func (s *MapTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitMapType(s)
	}
}

func (s *MapTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitMapType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) MapType() (localctx IMapTypeContext) {
	localctx = NewMapTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, GoParserRULE_mapType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Match(GoParserMAP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(729)
		p.Match(GoParserL_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(730)
		p.Type_()
	}
	{
		p.SetState(731)
		p.Match(GoParserR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(732)
		p.ElementType()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IChannelTypeContext is an interface to support dynamic dispatch.
type IChannelTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementType() IElementTypeContext
	CHAN() antlr.TerminalNode
	RECEIVE() antlr.TerminalNode

	// IsChannelTypeContext differentiates from other interfaces.
	IsChannelTypeContext()
}

type ChannelTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelTypeContext() *ChannelTypeContext {
	var p = new(ChannelTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_channelType
	return p
}

func InitEmptyChannelTypeContext(p *ChannelTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_channelType
}

func (*ChannelTypeContext) IsChannelTypeContext() {}

func NewChannelTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelTypeContext {
	var p = new(ChannelTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_channelType

	return p
}

func (s *ChannelTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelTypeContext) ElementType() IElementTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTypeContext)
}

func (s *ChannelTypeContext) CHAN() antlr.TerminalNode {
	return s.GetToken(GoParserCHAN, 0)
}

func (s *ChannelTypeContext) RECEIVE() antlr.TerminalNode {
	return s.GetToken(GoParserRECEIVE, 0)
}

func (s *ChannelTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ChannelTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterChannelType(s)
	}
}

func (s *ChannelTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitChannelType(s)
	}
}

func (s *ChannelTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitChannelType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ChannelType() (localctx IChannelTypeContext) {
	localctx = NewChannelTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, GoParserRULE_channelType)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(734)
			p.Match(GoParserCHAN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		{
			p.SetState(735)
			p.Match(GoParserCHAN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(736)
			p.Match(GoParserRECEIVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		{
			p.SetState(737)
			p.Match(GoParserRECEIVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(738)
			p.Match(GoParserCHAN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(741)
		p.ElementType()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMethodSpecContext is an interface to support dynamic dispatch.
type IMethodSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Parameters() IParametersContext
	Result() IResultContext

	// IsMethodSpecContext differentiates from other interfaces.
	IsMethodSpecContext()
}

type MethodSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodSpecContext() *MethodSpecContext {
	var p = new(MethodSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_methodSpec
	return p
}

func InitEmptyMethodSpecContext(p *MethodSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_methodSpec
}

func (*MethodSpecContext) IsMethodSpecContext() {}

func NewMethodSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodSpecContext {
	var p = new(MethodSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_methodSpec

	return p
}

func (s *MethodSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *MethodSpecContext) Parameters() IParametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *MethodSpecContext) Result() IResultContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultContext)
}

func (s *MethodSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MethodSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterMethodSpec(s)
	}
}

func (s *MethodSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitMethodSpec(s)
	}
}

func (s *MethodSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitMethodSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) MethodSpec() (localctx IMethodSpecContext) {
	localctx = NewMethodSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, GoParserRULE_methodSpec)
	p.SetState(749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(743)
			p.Match(GoParserIDENTIFIER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(744)
			p.Parameters()
		}
		{
			p.SetState(745)
			p.Result()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(747)
			p.Match(GoParserIDENTIFIER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(748)
			p.Parameters()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNC() antlr.TerminalNode
	Signature() ISignatureContext

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) FUNC() antlr.TerminalNode {
	return s.GetToken(GoParserFUNC, 0)
}

func (s *FunctionTypeContext) Signature() ISignatureContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignatureContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignatureContext)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (s *FunctionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitFunctionType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, GoParserRULE_functionType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(751)
		p.Match(GoParserFUNC)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(752)
		p.Signature()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISignatureContext is an interface to support dynamic dispatch.
type ISignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parameters() IParametersContext
	Result() IResultContext

	// IsSignatureContext differentiates from other interfaces.
	IsSignatureContext()
}

type SignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignatureContext() *SignatureContext {
	var p = new(SignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_signature
	return p
}

func InitEmptySignatureContext(p *SignatureContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_signature
}

func (*SignatureContext) IsSignatureContext() {}

func NewSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignatureContext {
	var p = new(SignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_signature

	return p
}

func (s *SignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *SignatureContext) Parameters() IParametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *SignatureContext) Result() IResultContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultContext)
}

func (s *SignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterSignature(s)
	}
}

func (s *SignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitSignature(s)
	}
}

func (s *SignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitSignature(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Signature() (localctx ISignatureContext) {
	localctx = NewSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, GoParserRULE_signature)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(754)
		p.Parameters()
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(755)
			p.Result()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IResultContext is an interface to support dynamic dispatch.
type IResultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parameters() IParametersContext
	Type_() IType_Context

	// IsResultContext differentiates from other interfaces.
	IsResultContext()
}

type ResultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultContext() *ResultContext {
	var p = new(ResultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_result
	return p
}

func InitEmptyResultContext(p *ResultContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_result
}

func (*ResultContext) IsResultContext() {}

func NewResultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultContext {
	var p = new(ResultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_result

	return p
}

func (s *ResultContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultContext) Parameters() IParametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *ResultContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ResultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ResultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterResult(s)
	}
}

func (s *ResultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitResult(s)
	}
}

func (s *ResultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitResult(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Result() (localctx IResultContext) {
	localctx = NewResultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, GoParserRULE_result)
	p.SetState(760)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(758)
			p.Parameters()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(759)
			p.Type_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_PAREN() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	AllParameterDecl() []IParameterDeclContext
	ParameterDecl(i int) IParameterDeclContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_parameters
	return p
}

func InitEmptyParametersContext(p *ParametersContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_parameters
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserL_PAREN, 0)
}

func (s *ParametersContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserR_PAREN, 0)
}

func (s *ParametersContext) AllParameterDecl() []IParameterDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterDeclContext); ok {
			len++
		}
	}

	tst := make([]IParameterDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterDeclContext); ok {
			tst[i] = t.(IParameterDeclContext)
			i++
		}
	}

	return tst
}

func (s *ParametersContext) ParameterDecl(i int) IParameterDeclContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterDeclContext)
}

func (s *ParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GoParserCOMMA)
}

func (s *ParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GoParserCOMMA, i)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitParameters(s)
	}
}

func (s *ParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitParameters(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, GoParserRULE_parameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(762)
		p.Match(GoParserL_PAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 3)) & ^0x3f) == 0 && ((int64(1) << (_la - 3)) & -6917526826269015613) != 0) {
		{
			p.SetState(763)
			p.ParameterDecl()
		}
		p.SetState(768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(764)
					p.Match(GoParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(765)
					p.ParameterDecl()
				}


			}
			p.SetState(770)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(772)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoParserCOMMA {
			{
				p.SetState(771)
				p.Match(GoParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}

	}
	{
		p.SetState(776)
		p.Match(GoParserR_PAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IParameterDeclContext is an interface to support dynamic dispatch.
type IParameterDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context
	IdentifierList() IIdentifierListContext
	ELLIPSIS() antlr.TerminalNode

	// IsParameterDeclContext differentiates from other interfaces.
	IsParameterDeclContext()
}

type ParameterDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterDeclContext() *ParameterDeclContext {
	var p = new(ParameterDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_parameterDecl
	return p
}

func InitEmptyParameterDeclContext(p *ParameterDeclContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_parameterDecl
}

func (*ParameterDeclContext) IsParameterDeclContext() {}

func NewParameterDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDeclContext {
	var p = new(ParameterDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_parameterDecl

	return p
}

func (s *ParameterDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterDeclContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ParameterDeclContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ParameterDeclContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(GoParserELLIPSIS, 0)
}

func (s *ParameterDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParameterDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterParameterDecl(s)
	}
}

func (s *ParameterDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitParameterDecl(s)
	}
}

func (s *ParameterDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitParameterDecl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ParameterDecl() (localctx IParameterDeclContext) {
	localctx = NewParameterDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, GoParserRULE_parameterDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(779)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(778)
			p.IdentifierList()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserELLIPSIS {
		{
			p.SetState(781)
			p.Match(GoParserELLIPSIS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(784)
		p.Type_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnary_op returns the unary_op token.
	GetUnary_op() antlr.Token 

	// GetMul_op returns the mul_op token.
	GetMul_op() antlr.Token 

	// GetAdd_op returns the add_op token.
	GetAdd_op() antlr.Token 

	// GetRel_op returns the rel_op token.
	GetRel_op() antlr.Token 


	// SetUnary_op sets the unary_op token.
	SetUnary_op(antlr.Token) 

	// SetMul_op sets the mul_op token.
	SetMul_op(antlr.Token) 

	// SetAdd_op sets the add_op token.
	SetAdd_op(antlr.Token) 

	// SetRel_op sets the rel_op token.
	SetRel_op(antlr.Token) 


	// Getter signatures
	PrimaryExpr() IPrimaryExprContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	EXCLAMATION() antlr.TerminalNode
	CARET() antlr.TerminalNode
	STAR() antlr.TerminalNode
	AMPERSAND() antlr.TerminalNode
	RECEIVE() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	LSHIFT() antlr.TerminalNode
	RSHIFT() antlr.TerminalNode
	BIT_CLEAR() antlr.TerminalNode
	OR() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	NOT_EQUALS() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LESS_OR_EQUALS() antlr.TerminalNode
	GREATER() antlr.TerminalNode
	GREATER_OR_EQUALS() antlr.TerminalNode
	LOGICAL_AND() antlr.TerminalNode
	LOGICAL_OR() antlr.TerminalNode

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	unary_op antlr.Token
	mul_op antlr.Token
	add_op antlr.Token
	rel_op antlr.Token
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) GetUnary_op() antlr.Token { return s.unary_op }

func (s *ExpressionContext) GetMul_op() antlr.Token { return s.mul_op }

func (s *ExpressionContext) GetAdd_op() antlr.Token { return s.add_op }

func (s *ExpressionContext) GetRel_op() antlr.Token { return s.rel_op }


func (s *ExpressionContext) SetUnary_op(v antlr.Token) { s.unary_op = v }

func (s *ExpressionContext) SetMul_op(v antlr.Token) { s.mul_op = v }

func (s *ExpressionContext) SetAdd_op(v antlr.Token) { s.add_op = v }

func (s *ExpressionContext) SetRel_op(v antlr.Token) { s.rel_op = v }


func (s *ExpressionContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) PLUS() antlr.TerminalNode {
	return s.GetToken(GoParserPLUS, 0)
}

func (s *ExpressionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(GoParserMINUS, 0)
}

func (s *ExpressionContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(GoParserEXCLAMATION, 0)
}

func (s *ExpressionContext) CARET() antlr.TerminalNode {
	return s.GetToken(GoParserCARET, 0)
}

func (s *ExpressionContext) STAR() antlr.TerminalNode {
	return s.GetToken(GoParserSTAR, 0)
}

func (s *ExpressionContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(GoParserAMPERSAND, 0)
}

func (s *ExpressionContext) RECEIVE() antlr.TerminalNode {
	return s.GetToken(GoParserRECEIVE, 0)
}

func (s *ExpressionContext) DIV() antlr.TerminalNode {
	return s.GetToken(GoParserDIV, 0)
}

func (s *ExpressionContext) MOD() antlr.TerminalNode {
	return s.GetToken(GoParserMOD, 0)
}

func (s *ExpressionContext) LSHIFT() antlr.TerminalNode {
	return s.GetToken(GoParserLSHIFT, 0)
}

func (s *ExpressionContext) RSHIFT() antlr.TerminalNode {
	return s.GetToken(GoParserRSHIFT, 0)
}

func (s *ExpressionContext) BIT_CLEAR() antlr.TerminalNode {
	return s.GetToken(GoParserBIT_CLEAR, 0)
}

func (s *ExpressionContext) OR() antlr.TerminalNode {
	return s.GetToken(GoParserOR, 0)
}

func (s *ExpressionContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(GoParserEQUALS, 0)
}

func (s *ExpressionContext) NOT_EQUALS() antlr.TerminalNode {
	return s.GetToken(GoParserNOT_EQUALS, 0)
}

func (s *ExpressionContext) LESS() antlr.TerminalNode {
	return s.GetToken(GoParserLESS, 0)
}

func (s *ExpressionContext) LESS_OR_EQUALS() antlr.TerminalNode {
	return s.GetToken(GoParserLESS_OR_EQUALS, 0)
}

func (s *ExpressionContext) GREATER() antlr.TerminalNode {
	return s.GetToken(GoParserGREATER, 0)
}

func (s *ExpressionContext) GREATER_OR_EQUALS() antlr.TerminalNode {
	return s.GetToken(GoParserGREATER_OR_EQUALS, 0)
}

func (s *ExpressionContext) LOGICAL_AND() antlr.TerminalNode {
	return s.GetToken(GoParserLOGICAL_AND, 0)
}

func (s *ExpressionContext) LOGICAL_OR() antlr.TerminalNode {
	return s.GetToken(GoParserLOGICAL_OR, 0)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *GoParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 152
	p.EnterRecursionRule(localctx, 152, GoParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(787)
			p.primaryExpr(0)
		}


	case 2:
		{
			p.SetState(788)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExpressionContext).unary_op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 60)) & ^0x3f) == 0 && ((int64(1) << (_la - 60)) & 127) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExpressionContext).unary_op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(789)
			p.expression(6)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(809)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(807)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoParserRULE_expression)
				p.SetState(792)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(793)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).mul_op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((int64((_la - 54)) & ^0x3f) == 0 && ((int64(1) << (_la - 54)) & 3103) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).mul_op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(794)
					p.expression(6)
				}


			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoParserRULE_expression)
				p.SetState(795)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(796)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).add_op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -2296835809958952960) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).add_op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(797)
					p.expression(5)
				}


			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoParserRULE_expression)
				p.SetState(798)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(799)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).rel_op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 8866461766385664) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).rel_op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(800)
					p.expression(4)
				}


			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoParserRULE_expression)
				p.SetState(801)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(802)
					p.Match(GoParserLOGICAL_AND)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(803)
					p.expression(3)
				}


			case 5:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GoParserRULE_expression)
				p.SetState(804)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(805)
					p.Match(GoParserLOGICAL_OR)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(806)
					p.expression(2)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrimaryExprContext is an interface to support dynamic dispatch.
type IPrimaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Operand() IOperandContext
	Conversion() IConversionContext
	MethodExpr() IMethodExprContext
	PrimaryExpr() IPrimaryExprContext
	DOT() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	Index() IIndexContext
	Slice_() ISlice_Context
	TypeAssertion() ITypeAssertionContext
	Arguments() IArgumentsContext

	// IsPrimaryExprContext differentiates from other interfaces.
	IsPrimaryExprContext()
}

type PrimaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExprContext() *PrimaryExprContext {
	var p = new(PrimaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_primaryExpr
	return p
}

func InitEmptyPrimaryExprContext(p *PrimaryExprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_primaryExpr
}

func (*PrimaryExprContext) IsPrimaryExprContext() {}

func NewPrimaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExprContext {
	var p = new(PrimaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_primaryExpr

	return p
}

func (s *PrimaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExprContext) Operand() IOperandContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperandContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperandContext)
}

func (s *PrimaryExprContext) Conversion() IConversionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConversionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConversionContext)
}

func (s *PrimaryExprContext) MethodExpr() IMethodExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodExprContext)
}

func (s *PrimaryExprContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *PrimaryExprContext) DOT() antlr.TerminalNode {
	return s.GetToken(GoParserDOT, 0)
}

func (s *PrimaryExprContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *PrimaryExprContext) Index() IIndexContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexContext)
}

func (s *PrimaryExprContext) Slice_() ISlice_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlice_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlice_Context)
}

func (s *PrimaryExprContext) TypeAssertion() ITypeAssertionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAssertionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAssertionContext)
}

func (s *PrimaryExprContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *PrimaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrimaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterPrimaryExpr(s)
	}
}

func (s *PrimaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitPrimaryExpr(s)
	}
}

func (s *PrimaryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitPrimaryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}





func (p *GoParser) PrimaryExpr() (localctx IPrimaryExprContext) {
	return p.primaryExpr(0)
}

func (p *GoParser) primaryExpr(_p int) (localctx IPrimaryExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 154
	p.EnterRecursionRule(localctx, 154, GoParserRULE_primaryExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(816)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(813)
			p.Operand()
		}


	case 2:
		{
			p.SetState(814)
			p.Conversion()
		}


	case 3:
		{
			p.SetState(815)
			p.MethodExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(829)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPrimaryExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, GoParserRULE_primaryExpr)
			p.SetState(818)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			p.SetState(825)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(819)
					p.Match(GoParserDOT)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(820)
					p.Match(GoParserIDENTIFIER)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case 2:
				{
					p.SetState(821)
					p.Index()
				}


			case 3:
				{
					p.SetState(822)
					p.Slice_()
				}


			case 4:
				{
					p.SetState(823)
					p.TypeAssertion()
				}


			case 5:
				{
					p.SetState(824)
					p.Arguments()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}


		}
		p.SetState(831)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConversionContext is an interface to support dynamic dispatch.
type IConversionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context
	L_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	R_PAREN() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsConversionContext differentiates from other interfaces.
	IsConversionContext()
}

type ConversionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConversionContext() *ConversionContext {
	var p = new(ConversionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_conversion
	return p
}

func InitEmptyConversionContext(p *ConversionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_conversion
}

func (*ConversionContext) IsConversionContext() {}

func NewConversionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConversionContext {
	var p = new(ConversionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_conversion

	return p
}

func (s *ConversionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConversionContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ConversionContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserL_PAREN, 0)
}

func (s *ConversionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConversionContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserR_PAREN, 0)
}

func (s *ConversionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GoParserCOMMA, 0)
}

func (s *ConversionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConversionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConversionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterConversion(s)
	}
}

func (s *ConversionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitConversion(s)
	}
}

func (s *ConversionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitConversion(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Conversion() (localctx IConversionContext) {
	localctx = NewConversionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, GoParserRULE_conversion)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(832)
		p.Type_()
	}
	{
		p.SetState(833)
		p.Match(GoParserL_PAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(834)
		p.expression(0)
	}
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserCOMMA {
		{
			p.SetState(835)
			p.Match(GoParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(838)
		p.Match(GoParserR_PAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOperandContext is an interface to support dynamic dispatch.
type IOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	OperandName() IOperandNameContext
	L_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	R_PAREN() antlr.TerminalNode

	// IsOperandContext differentiates from other interfaces.
	IsOperandContext()
}

type OperandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperandContext() *OperandContext {
	var p = new(OperandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_operand
	return p
}

func InitEmptyOperandContext(p *OperandContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_operand
}

func (*OperandContext) IsOperandContext() {}

func NewOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperandContext {
	var p = new(OperandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_operand

	return p
}

func (s *OperandContext) GetParser() antlr.Parser { return s.parser }

func (s *OperandContext) Literal() ILiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *OperandContext) OperandName() IOperandNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperandNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperandNameContext)
}

func (s *OperandContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserL_PAREN, 0)
}

func (s *OperandContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OperandContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserR_PAREN, 0)
}

func (s *OperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterOperand(s)
	}
}

func (s *OperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitOperand(s)
	}
}

func (s *OperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitOperand(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Operand() (localctx IOperandContext) {
	localctx = NewOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, GoParserRULE_operand)
	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(840)
			p.Literal()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(841)
			p.OperandName()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(842)
			p.Match(GoParserL_PAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(843)
			p.expression(0)
		}
		{
			p.SetState(844)
			p.Match(GoParserR_PAREN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BasicLit() IBasicLitContext
	CompositeLit() ICompositeLitContext
	FunctionLit() IFunctionLitContext

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) BasicLit() IBasicLitContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBasicLitContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBasicLitContext)
}

func (s *LiteralContext) CompositeLit() ICompositeLitContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompositeLitContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompositeLitContext)
}

func (s *LiteralContext) FunctionLit() IFunctionLitContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionLitContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionLitContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, GoParserRULE_literal)
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserNIL_LIT, GoParserTRUE_LIT, GoParserFALSE_LIT, GoParserDECIMAL_LIT, GoParserBINARY_LIT, GoParserOCTAL_LIT, GoParserHEX_LIT, GoParserFLOAT_LIT, GoParserIMAGINARY_LIT, GoParserRUNE_LIT, GoParserRAW_STRING_LIT, GoParserINTERPRETED_STRING_LIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(848)
			p.BasicLit()
		}


	case GoParserMAP, GoParserSTRUCT, GoParserIDENTIFIER, GoParserL_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(849)
			p.CompositeLit()
		}


	case GoParserFUNC:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(850)
			p.FunctionLit()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBasicLitContext is an interface to support dynamic dispatch.
type IBasicLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NIL_LIT() antlr.TerminalNode
	Integer() IIntegerContext
	String_() IString_Context
	FLOAT_LIT() antlr.TerminalNode
	TRUE_LIT() antlr.TerminalNode
	FALSE_LIT() antlr.TerminalNode

	// IsBasicLitContext differentiates from other interfaces.
	IsBasicLitContext()
}

type BasicLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasicLitContext() *BasicLitContext {
	var p = new(BasicLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_basicLit
	return p
}

func InitEmptyBasicLitContext(p *BasicLitContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_basicLit
}

func (*BasicLitContext) IsBasicLitContext() {}

func NewBasicLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasicLitContext {
	var p = new(BasicLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_basicLit

	return p
}

func (s *BasicLitContext) GetParser() antlr.Parser { return s.parser }

func (s *BasicLitContext) NIL_LIT() antlr.TerminalNode {
	return s.GetToken(GoParserNIL_LIT, 0)
}

func (s *BasicLitContext) Integer() IIntegerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *BasicLitContext) String_() IString_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *BasicLitContext) FLOAT_LIT() antlr.TerminalNode {
	return s.GetToken(GoParserFLOAT_LIT, 0)
}

func (s *BasicLitContext) TRUE_LIT() antlr.TerminalNode {
	return s.GetToken(GoParserTRUE_LIT, 0)
}

func (s *BasicLitContext) FALSE_LIT() antlr.TerminalNode {
	return s.GetToken(GoParserFALSE_LIT, 0)
}

func (s *BasicLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BasicLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterBasicLit(s)
	}
}

func (s *BasicLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitBasicLit(s)
	}
}

func (s *BasicLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitBasicLit(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) BasicLit() (localctx IBasicLitContext) {
	localctx = NewBasicLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, GoParserRULE_basicLit)
	p.SetState(859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserNIL_LIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(853)
			p.Match(GoParserNIL_LIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoParserDECIMAL_LIT, GoParserBINARY_LIT, GoParserOCTAL_LIT, GoParserHEX_LIT, GoParserIMAGINARY_LIT, GoParserRUNE_LIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(854)
			p.Integer()
		}


	case GoParserRAW_STRING_LIT, GoParserINTERPRETED_STRING_LIT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(855)
			p.String_()
		}


	case GoParserFLOAT_LIT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(856)
			p.Match(GoParserFLOAT_LIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoParserTRUE_LIT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(857)
			p.Match(GoParserTRUE_LIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case GoParserFALSE_LIT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(858)
			p.Match(GoParserFALSE_LIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIntegerContext is an interface to support dynamic dispatch.
type IIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_LIT() antlr.TerminalNode
	BINARY_LIT() antlr.TerminalNode
	OCTAL_LIT() antlr.TerminalNode
	HEX_LIT() antlr.TerminalNode
	IMAGINARY_LIT() antlr.TerminalNode
	RUNE_LIT() antlr.TerminalNode

	// IsIntegerContext differentiates from other interfaces.
	IsIntegerContext()
}

type IntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerContext() *IntegerContext {
	var p = new(IntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_integer
	return p
}

func InitEmptyIntegerContext(p *IntegerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_integer
}

func (*IntegerContext) IsIntegerContext() {}

func NewIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerContext {
	var p = new(IntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_integer

	return p
}

func (s *IntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerContext) DECIMAL_LIT() antlr.TerminalNode {
	return s.GetToken(GoParserDECIMAL_LIT, 0)
}

func (s *IntegerContext) BINARY_LIT() antlr.TerminalNode {
	return s.GetToken(GoParserBINARY_LIT, 0)
}

func (s *IntegerContext) OCTAL_LIT() antlr.TerminalNode {
	return s.GetToken(GoParserOCTAL_LIT, 0)
}

func (s *IntegerContext) HEX_LIT() antlr.TerminalNode {
	return s.GetToken(GoParserHEX_LIT, 0)
}

func (s *IntegerContext) IMAGINARY_LIT() antlr.TerminalNode {
	return s.GetToken(GoParserIMAGINARY_LIT, 0)
}

func (s *IntegerContext) RUNE_LIT() antlr.TerminalNode {
	return s.GetToken(GoParserRUNE_LIT, 0)
}

func (s *IntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterInteger(s)
	}
}

func (s *IntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitInteger(s)
	}
}

func (s *IntegerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitInteger(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Integer() (localctx IIntegerContext) {
	localctx = NewIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, GoParserRULE_integer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(861)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 67)) & ^0x3f) == 0 && ((int64(1) << (_la - 67)) & 399) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOperandNameContext is an interface to support dynamic dispatch.
type IOperandNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode

	// IsOperandNameContext differentiates from other interfaces.
	IsOperandNameContext()
}

type OperandNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperandNameContext() *OperandNameContext {
	var p = new(OperandNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_operandName
	return p
}

func InitEmptyOperandNameContext(p *OperandNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_operandName
}

func (*OperandNameContext) IsOperandNameContext() {}

func NewOperandNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperandNameContext {
	var p = new(OperandNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_operandName

	return p
}

func (s *OperandNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OperandNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *OperandNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperandNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OperandNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterOperandName(s)
	}
}

func (s *OperandNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitOperandName(s)
	}
}

func (s *OperandNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitOperandName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) OperandName() (localctx IOperandNameContext) {
	localctx = NewOperandNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, GoParserRULE_operandName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(863)
		p.Match(GoParserIDENTIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQualifiedIdentContext is an interface to support dynamic dispatch.
type IQualifiedIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsQualifiedIdentContext differentiates from other interfaces.
	IsQualifiedIdentContext()
}

type QualifiedIdentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedIdentContext() *QualifiedIdentContext {
	var p = new(QualifiedIdentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_qualifiedIdent
	return p
}

func InitEmptyQualifiedIdentContext(p *QualifiedIdentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_qualifiedIdent
}

func (*QualifiedIdentContext) IsQualifiedIdentContext() {}

func NewQualifiedIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedIdentContext {
	var p = new(QualifiedIdentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_qualifiedIdent

	return p
}

func (s *QualifiedIdentContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedIdentContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(GoParserIDENTIFIER)
}

func (s *QualifiedIdentContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, i)
}

func (s *QualifiedIdentContext) DOT() antlr.TerminalNode {
	return s.GetToken(GoParserDOT, 0)
}

func (s *QualifiedIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QualifiedIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterQualifiedIdent(s)
	}
}

func (s *QualifiedIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitQualifiedIdent(s)
	}
}

func (s *QualifiedIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitQualifiedIdent(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) QualifiedIdent() (localctx IQualifiedIdentContext) {
	localctx = NewQualifiedIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, GoParserRULE_qualifiedIdent)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(865)
		p.Match(GoParserIDENTIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(866)
		p.Match(GoParserDOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(867)
		p.Match(GoParserIDENTIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICompositeLitContext is an interface to support dynamic dispatch.
type ICompositeLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LiteralType() ILiteralTypeContext
	LiteralValue() ILiteralValueContext

	// IsCompositeLitContext differentiates from other interfaces.
	IsCompositeLitContext()
}

type CompositeLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompositeLitContext() *CompositeLitContext {
	var p = new(CompositeLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_compositeLit
	return p
}

func InitEmptyCompositeLitContext(p *CompositeLitContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_compositeLit
}

func (*CompositeLitContext) IsCompositeLitContext() {}

func NewCompositeLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompositeLitContext {
	var p = new(CompositeLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_compositeLit

	return p
}

func (s *CompositeLitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompositeLitContext) LiteralType() ILiteralTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralTypeContext)
}

func (s *CompositeLitContext) LiteralValue() ILiteralValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralValueContext)
}

func (s *CompositeLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompositeLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CompositeLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterCompositeLit(s)
	}
}

func (s *CompositeLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitCompositeLit(s)
	}
}

func (s *CompositeLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitCompositeLit(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) CompositeLit() (localctx ICompositeLitContext) {
	localctx = NewCompositeLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, GoParserRULE_compositeLit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(869)
		p.LiteralType()
	}
	{
		p.SetState(870)
		p.LiteralValue()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILiteralTypeContext is an interface to support dynamic dispatch.
type ILiteralTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StructType() IStructTypeContext
	ArrayType() IArrayTypeContext
	L_BRACKET() antlr.TerminalNode
	ELLIPSIS() antlr.TerminalNode
	R_BRACKET() antlr.TerminalNode
	ElementType() IElementTypeContext
	SliceType() ISliceTypeContext
	MapType() IMapTypeContext
	TypeName() ITypeNameContext
	TypeArgs() ITypeArgsContext

	// IsLiteralTypeContext differentiates from other interfaces.
	IsLiteralTypeContext()
}

type LiteralTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralTypeContext() *LiteralTypeContext {
	var p = new(LiteralTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_literalType
	return p
}

func InitEmptyLiteralTypeContext(p *LiteralTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_literalType
}

func (*LiteralTypeContext) IsLiteralTypeContext() {}

func NewLiteralTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralTypeContext {
	var p = new(LiteralTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_literalType

	return p
}

func (s *LiteralTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralTypeContext) StructType() IStructTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructTypeContext)
}

func (s *LiteralTypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *LiteralTypeContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserL_BRACKET, 0)
}

func (s *LiteralTypeContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(GoParserELLIPSIS, 0)
}

func (s *LiteralTypeContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserR_BRACKET, 0)
}

func (s *LiteralTypeContext) ElementType() IElementTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTypeContext)
}

func (s *LiteralTypeContext) SliceType() ISliceTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISliceTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISliceTypeContext)
}

func (s *LiteralTypeContext) MapType() IMapTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *LiteralTypeContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *LiteralTypeContext) TypeArgs() ITypeArgsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgsContext)
}

func (s *LiteralTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LiteralTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterLiteralType(s)
	}
}

func (s *LiteralTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitLiteralType(s)
	}
}

func (s *LiteralTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitLiteralType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) LiteralType() (localctx ILiteralTypeContext) {
	localctx = NewLiteralTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, GoParserRULE_literalType)
	var _la int

	p.SetState(884)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(872)
			p.StructType()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(873)
			p.ArrayType()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(874)
			p.Match(GoParserL_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(875)
			p.Match(GoParserELLIPSIS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(876)
			p.Match(GoParserR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(877)
			p.ElementType()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(878)
			p.SliceType()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(879)
			p.MapType()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(880)
			p.TypeName()
		}
		p.SetState(882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoParserL_BRACKET {
			{
				p.SetState(881)
				p.TypeArgs()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILiteralValueContext is an interface to support dynamic dispatch.
type ILiteralValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_CURLY() antlr.TerminalNode
	R_CURLY() antlr.TerminalNode
	ElementList() IElementListContext
	COMMA() antlr.TerminalNode

	// IsLiteralValueContext differentiates from other interfaces.
	IsLiteralValueContext()
}

type LiteralValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralValueContext() *LiteralValueContext {
	var p = new(LiteralValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_literalValue
	return p
}

func InitEmptyLiteralValueContext(p *LiteralValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_literalValue
}

func (*LiteralValueContext) IsLiteralValueContext() {}

func NewLiteralValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralValueContext {
	var p = new(LiteralValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_literalValue

	return p
}

func (s *LiteralValueContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralValueContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserL_CURLY, 0)
}

func (s *LiteralValueContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserR_CURLY, 0)
}

func (s *LiteralValueContext) ElementList() IElementListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *LiteralValueContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GoParserCOMMA, 0)
}

func (s *LiteralValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LiteralValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterLiteralValue(s)
	}
}

func (s *LiteralValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitLiteralValue(s)
	}
}

func (s *LiteralValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitLiteralValue(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) LiteralValue() (localctx ILiteralValueContext) {
	localctx = NewLiteralValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, GoParserRULE_literalValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(886)
		p.Match(GoParserL_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921481051632104) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
		{
			p.SetState(887)
			p.ElementList()
		}
		p.SetState(889)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoParserCOMMA {
			{
				p.SetState(888)
				p.Match(GoParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}

	}
	{
		p.SetState(893)
		p.Match(GoParserR_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllKeyedElement() []IKeyedElementContext
	KeyedElement(i int) IKeyedElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_elementList
	return p
}

func InitEmptyElementListContext(p *ElementListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_elementList
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllKeyedElement() []IKeyedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyedElementContext); ok {
			len++
		}
	}

	tst := make([]IKeyedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyedElementContext); ok {
			tst[i] = t.(IKeyedElementContext)
			i++
		}
	}

	return tst
}

func (s *ElementListContext) KeyedElement(i int) IKeyedElementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedElementContext)
}

func (s *ElementListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GoParserCOMMA)
}

func (s *ElementListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GoParserCOMMA, i)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterElementList(s)
	}
}

func (s *ElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitElementList(s)
	}
}

func (s *ElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitElementList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) ElementList() (localctx IElementListContext) {
	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, GoParserRULE_elementList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(895)
		p.KeyedElement()
	}
	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(896)
				p.Match(GoParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(897)
				p.KeyedElement()
			}


		}
		p.SetState(902)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyedElementContext is an interface to support dynamic dispatch.
type IKeyedElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Element() IElementContext
	Key() IKeyContext
	COLON() antlr.TerminalNode

	// IsKeyedElementContext differentiates from other interfaces.
	IsKeyedElementContext()
}

type KeyedElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyedElementContext() *KeyedElementContext {
	var p = new(KeyedElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_keyedElement
	return p
}

func InitEmptyKeyedElementContext(p *KeyedElementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_keyedElement
}

func (*KeyedElementContext) IsKeyedElementContext() {}

func NewKeyedElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyedElementContext {
	var p = new(KeyedElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_keyedElement

	return p
}

func (s *KeyedElementContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyedElementContext) Element() IElementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementContext)
}

func (s *KeyedElementContext) Key() IKeyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyContext)
}

func (s *KeyedElementContext) COLON() antlr.TerminalNode {
	return s.GetToken(GoParserCOLON, 0)
}

func (s *KeyedElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyedElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KeyedElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterKeyedElement(s)
	}
}

func (s *KeyedElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitKeyedElement(s)
	}
}

func (s *KeyedElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitKeyedElement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) KeyedElement() (localctx IKeyedElementContext) {
	localctx = NewKeyedElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, GoParserRULE_keyedElement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(906)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(903)
			p.Key()
		}
		{
			p.SetState(904)
			p.Match(GoParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(908)
		p.Element()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyContext is an interface to support dynamic dispatch.
type IKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	LiteralValue() ILiteralValueContext

	// IsKeyContext differentiates from other interfaces.
	IsKeyContext()
}

type KeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyContext() *KeyContext {
	var p = new(KeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_key
	return p
}

func InitEmptyKeyContext(p *KeyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_key
}

func (*KeyContext) IsKeyContext() {}

func NewKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyContext {
	var p = new(KeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_key

	return p
}

func (s *KeyContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KeyContext) LiteralValue() ILiteralValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralValueContext)
}

func (s *KeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterKey(s)
	}
}

func (s *KeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitKey(s)
	}
}

func (s *KeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitKey(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Key() (localctx IKeyContext) {
	localctx = NewKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, GoParserRULE_key)
	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserFUNC, GoParserINTERFACE, GoParserMAP, GoParserSTRUCT, GoParserCHAN, GoParserNIL_LIT, GoParserTRUE_LIT, GoParserFALSE_LIT, GoParserIDENTIFIER, GoParserL_PAREN, GoParserL_BRACKET, GoParserEXCLAMATION, GoParserPLUS, GoParserMINUS, GoParserCARET, GoParserSTAR, GoParserAMPERSAND, GoParserRECEIVE, GoParserDECIMAL_LIT, GoParserBINARY_LIT, GoParserOCTAL_LIT, GoParserHEX_LIT, GoParserFLOAT_LIT, GoParserIMAGINARY_LIT, GoParserRUNE_LIT, GoParserRAW_STRING_LIT, GoParserINTERPRETED_STRING_LIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(910)
			p.expression(0)
		}


	case GoParserL_CURLY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(911)
			p.LiteralValue()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IElementContext is an interface to support dynamic dispatch.
type IElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	LiteralValue() ILiteralValueContext

	// IsElementContext differentiates from other interfaces.
	IsElementContext()
}

type ElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementContext() *ElementContext {
	var p = new(ElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_element
	return p
}

func InitEmptyElementContext(p *ElementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_element
}

func (*ElementContext) IsElementContext() {}

func NewElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementContext {
	var p = new(ElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_element

	return p
}

func (s *ElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementContext) LiteralValue() ILiteralValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralValueContext)
}

func (s *ElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterElement(s)
	}
}

func (s *ElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitElement(s)
	}
}

func (s *ElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitElement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Element() (localctx IElementContext) {
	localctx = NewElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, GoParserRULE_element)
	p.SetState(916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoParserFUNC, GoParserINTERFACE, GoParserMAP, GoParserSTRUCT, GoParserCHAN, GoParserNIL_LIT, GoParserTRUE_LIT, GoParserFALSE_LIT, GoParserIDENTIFIER, GoParserL_PAREN, GoParserL_BRACKET, GoParserEXCLAMATION, GoParserPLUS, GoParserMINUS, GoParserCARET, GoParserSTAR, GoParserAMPERSAND, GoParserRECEIVE, GoParserDECIMAL_LIT, GoParserBINARY_LIT, GoParserOCTAL_LIT, GoParserHEX_LIT, GoParserFLOAT_LIT, GoParserIMAGINARY_LIT, GoParserRUNE_LIT, GoParserRAW_STRING_LIT, GoParserINTERPRETED_STRING_LIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(914)
			p.expression(0)
		}


	case GoParserL_CURLY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(915)
			p.LiteralValue()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStructTypeContext is an interface to support dynamic dispatch.
type IStructTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCT() antlr.TerminalNode
	L_CURLY() antlr.TerminalNode
	R_CURLY() antlr.TerminalNode
	AllFieldDecl() []IFieldDeclContext
	FieldDecl(i int) IFieldDeclContext
	AllEos() []IEosContext
	Eos(i int) IEosContext

	// IsStructTypeContext differentiates from other interfaces.
	IsStructTypeContext()
}

type StructTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructTypeContext() *StructTypeContext {
	var p = new(StructTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_structType
	return p
}

func InitEmptyStructTypeContext(p *StructTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_structType
}

func (*StructTypeContext) IsStructTypeContext() {}

func NewStructTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructTypeContext {
	var p = new(StructTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_structType

	return p
}

func (s *StructTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructTypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(GoParserSTRUCT, 0)
}

func (s *StructTypeContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserL_CURLY, 0)
}

func (s *StructTypeContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(GoParserR_CURLY, 0)
}

func (s *StructTypeContext) AllFieldDecl() []IFieldDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDeclContext); ok {
			len++
		}
	}

	tst := make([]IFieldDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDeclContext); ok {
			tst[i] = t.(IFieldDeclContext)
			i++
		}
	}

	return tst
}

func (s *StructTypeContext) FieldDecl(i int) IFieldDeclContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclContext)
}

func (s *StructTypeContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *StructTypeContext) Eos(i int) IEosContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *StructTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StructTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterStructType(s)
	}
}

func (s *StructTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitStructType(s)
	}
}

func (s *StructTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitStructType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) StructType() (localctx IStructTypeContext) {
	localctx = NewStructTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, GoParserRULE_structType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(918)
		p.Match(GoParserSTRUCT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(919)
		p.Match(GoParserL_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(925)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == GoParserIDENTIFIER || _la == GoParserSTAR {
		{
			p.SetState(920)
			p.FieldDecl()
		}
		{
			p.SetState(921)
			p.Eos()
		}


		p.SetState(927)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(928)
		p.Match(GoParserR_CURLY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFieldDeclContext is an interface to support dynamic dispatch.
type IFieldDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTag returns the tag rule contexts.
	GetTag() IString_Context


	// SetTag sets the tag rule contexts.
	SetTag(IString_Context)


	// Getter signatures
	IdentifierList() IIdentifierListContext
	Type_() IType_Context
	EmbeddedField() IEmbeddedFieldContext
	String_() IString_Context

	// IsFieldDeclContext differentiates from other interfaces.
	IsFieldDeclContext()
}

type FieldDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	tag IString_Context 
}

func NewEmptyFieldDeclContext() *FieldDeclContext {
	var p = new(FieldDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_fieldDecl
	return p
}

func InitEmptyFieldDeclContext(p *FieldDeclContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_fieldDecl
}

func (*FieldDeclContext) IsFieldDeclContext() {}

func NewFieldDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclContext {
	var p = new(FieldDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_fieldDecl

	return p
}

func (s *FieldDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclContext) GetTag() IString_Context { return s.tag }


func (s *FieldDeclContext) SetTag(v IString_Context) { s.tag = v }


func (s *FieldDeclContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *FieldDeclContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FieldDeclContext) EmbeddedField() IEmbeddedFieldContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmbeddedFieldContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmbeddedFieldContext)
}

func (s *FieldDeclContext) String_() IString_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *FieldDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FieldDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterFieldDecl(s)
	}
}

func (s *FieldDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitFieldDecl(s)
	}
}

func (s *FieldDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitFieldDecl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) FieldDecl() (localctx IFieldDeclContext) {
	localctx = NewFieldDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, GoParserRULE_fieldDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(930)
			p.IdentifierList()
		}
		{
			p.SetState(931)
			p.Type_()
		}


	case 2:
		{
			p.SetState(933)
			p.EmbeddedField()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(937)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserRAW_STRING_LIT || _la == GoParserINTERPRETED_STRING_LIT {
		{
			p.SetState(936)

			var _x = p.String_()


			localctx.(*FieldDeclContext).tag = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IString_Context is an interface to support dynamic dispatch.
type IString_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAW_STRING_LIT() antlr.TerminalNode
	INTERPRETED_STRING_LIT() antlr.TerminalNode

	// IsString_Context differentiates from other interfaces.
	IsString_Context()
}

type String_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_Context() *String_Context {
	var p = new(String_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_string_
	return p
}

func InitEmptyString_Context(p *String_Context)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_string_
}

func (*String_Context) IsString_Context() {}

func NewString_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_Context {
	var p = new(String_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_string_

	return p
}

func (s *String_Context) GetParser() antlr.Parser { return s.parser }

func (s *String_Context) RAW_STRING_LIT() antlr.TerminalNode {
	return s.GetToken(GoParserRAW_STRING_LIT, 0)
}

func (s *String_Context) INTERPRETED_STRING_LIT() antlr.TerminalNode {
	return s.GetToken(GoParserINTERPRETED_STRING_LIT, 0)
}

func (s *String_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *String_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterString_(s)
	}
}

func (s *String_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitString_(s)
	}
}

func (s *String_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitString_(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) String_() (localctx IString_Context) {
	localctx = NewString_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, GoParserRULE_string_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(939)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoParserRAW_STRING_LIT || _la == GoParserINTERPRETED_STRING_LIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEmbeddedFieldContext is an interface to support dynamic dispatch.
type IEmbeddedFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	STAR() antlr.TerminalNode
	TypeArgs() ITypeArgsContext

	// IsEmbeddedFieldContext differentiates from other interfaces.
	IsEmbeddedFieldContext()
}

type EmbeddedFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmbeddedFieldContext() *EmbeddedFieldContext {
	var p = new(EmbeddedFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_embeddedField
	return p
}

func InitEmptyEmbeddedFieldContext(p *EmbeddedFieldContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_embeddedField
}

func (*EmbeddedFieldContext) IsEmbeddedFieldContext() {}

func NewEmbeddedFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmbeddedFieldContext {
	var p = new(EmbeddedFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_embeddedField

	return p
}

func (s *EmbeddedFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *EmbeddedFieldContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *EmbeddedFieldContext) STAR() antlr.TerminalNode {
	return s.GetToken(GoParserSTAR, 0)
}

func (s *EmbeddedFieldContext) TypeArgs() ITypeArgsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgsContext)
}

func (s *EmbeddedFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmbeddedFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EmbeddedFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterEmbeddedField(s)
	}
}

func (s *EmbeddedFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitEmbeddedField(s)
	}
}

func (s *EmbeddedFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitEmbeddedField(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) EmbeddedField() (localctx IEmbeddedFieldContext) {
	localctx = NewEmbeddedFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, GoParserRULE_embeddedField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserSTAR {
		{
			p.SetState(941)
			p.Match(GoParserSTAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(944)
		p.TypeName()
	}
	p.SetState(946)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == GoParserL_BRACKET {
		{
			p.SetState(945)
			p.TypeArgs()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionLitContext is an interface to support dynamic dispatch.
type IFunctionLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNC() antlr.TerminalNode
	Signature() ISignatureContext
	Block() IBlockContext

	// IsFunctionLitContext differentiates from other interfaces.
	IsFunctionLitContext()
}

type FunctionLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionLitContext() *FunctionLitContext {
	var p = new(FunctionLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_functionLit
	return p
}

func InitEmptyFunctionLitContext(p *FunctionLitContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_functionLit
}

func (*FunctionLitContext) IsFunctionLitContext() {}

func NewFunctionLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionLitContext {
	var p = new(FunctionLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_functionLit

	return p
}

func (s *FunctionLitContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionLitContext) FUNC() antlr.TerminalNode {
	return s.GetToken(GoParserFUNC, 0)
}

func (s *FunctionLitContext) Signature() ISignatureContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignatureContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignatureContext)
}

func (s *FunctionLitContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterFunctionLit(s)
	}
}

func (s *FunctionLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitFunctionLit(s)
	}
}

func (s *FunctionLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitFunctionLit(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) FunctionLit() (localctx IFunctionLitContext) {
	localctx = NewFunctionLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, GoParserRULE_functionLit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(948)
		p.Match(GoParserFUNC)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(949)
		p.Signature()
	}
	{
		p.SetState(950)
		p.Block()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIndexContext is an interface to support dynamic dispatch.
type IIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_BRACKET() antlr.TerminalNode
	Expression() IExpressionContext
	R_BRACKET() antlr.TerminalNode

	// IsIndexContext differentiates from other interfaces.
	IsIndexContext()
}

type IndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexContext() *IndexContext {
	var p = new(IndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_index
	return p
}

func InitEmptyIndexContext(p *IndexContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_index
}

func (*IndexContext) IsIndexContext() {}

func NewIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexContext {
	var p = new(IndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_index

	return p
}

func (s *IndexContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserL_BRACKET, 0)
}

func (s *IndexContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserR_BRACKET, 0)
}

func (s *IndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterIndex(s)
	}
}

func (s *IndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitIndex(s)
	}
}

func (s *IndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitIndex(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Index() (localctx IIndexContext) {
	localctx = NewIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, GoParserRULE_index)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(952)
		p.Match(GoParserL_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(953)
		p.expression(0)
	}
	{
		p.SetState(954)
		p.Match(GoParserR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISlice_Context is an interface to support dynamic dispatch.
type ISlice_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_BRACKET() antlr.TerminalNode
	R_BRACKET() antlr.TerminalNode
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsSlice_Context differentiates from other interfaces.
	IsSlice_Context()
}

type Slice_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlice_Context() *Slice_Context {
	var p = new(Slice_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_slice_
	return p
}

func InitEmptySlice_Context(p *Slice_Context)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_slice_
}

func (*Slice_Context) IsSlice_Context() {}

func NewSlice_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Slice_Context {
	var p = new(Slice_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_slice_

	return p
}

func (s *Slice_Context) GetParser() antlr.Parser { return s.parser }

func (s *Slice_Context) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserL_BRACKET, 0)
}

func (s *Slice_Context) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(GoParserR_BRACKET, 0)
}

func (s *Slice_Context) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(GoParserCOLON)
}

func (s *Slice_Context) COLON(i int) antlr.TerminalNode {
	return s.GetToken(GoParserCOLON, i)
}

func (s *Slice_Context) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Slice_Context) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Slice_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Slice_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Slice_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterSlice_(s)
	}
}

func (s *Slice_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitSlice_(s)
	}
}

func (s *Slice_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitSlice_(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Slice_() (localctx ISlice_Context) {
	localctx = NewSlice_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, GoParserRULE_slice_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(956)
		p.Match(GoParserL_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(972)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		p.SetState(958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921485346599400) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
			{
				p.SetState(957)
				p.expression(0)
			}

		}
		{
			p.SetState(960)
			p.Match(GoParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921485346599400) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
			{
				p.SetState(961)
				p.expression(0)
			}

		}


	case 2:
		p.SetState(965)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921485346599400) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
			{
				p.SetState(964)
				p.expression(0)
			}

		}
		{
			p.SetState(967)
			p.Match(GoParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(968)
			p.expression(0)
		}
		{
			p.SetState(969)
			p.Match(GoParserCOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(970)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(974)
		p.Match(GoParserR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeAssertionContext is an interface to support dynamic dispatch.
type ITypeAssertionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	L_PAREN() antlr.TerminalNode
	Type_() IType_Context
	R_PAREN() antlr.TerminalNode

	// IsTypeAssertionContext differentiates from other interfaces.
	IsTypeAssertionContext()
}

type TypeAssertionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAssertionContext() *TypeAssertionContext {
	var p = new(TypeAssertionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeAssertion
	return p
}

func InitEmptyTypeAssertionContext(p *TypeAssertionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_typeAssertion
}

func (*TypeAssertionContext) IsTypeAssertionContext() {}

func NewTypeAssertionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAssertionContext {
	var p = new(TypeAssertionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_typeAssertion

	return p
}

func (s *TypeAssertionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAssertionContext) DOT() antlr.TerminalNode {
	return s.GetToken(GoParserDOT, 0)
}

func (s *TypeAssertionContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserL_PAREN, 0)
}

func (s *TypeAssertionContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeAssertionContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserR_PAREN, 0)
}

func (s *TypeAssertionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAssertionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeAssertionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterTypeAssertion(s)
	}
}

func (s *TypeAssertionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitTypeAssertion(s)
	}
}

func (s *TypeAssertionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitTypeAssertion(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) TypeAssertion() (localctx ITypeAssertionContext) {
	localctx = NewTypeAssertionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, GoParserRULE_typeAssertion)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(976)
		p.Match(GoParserDOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(977)
		p.Match(GoParserL_PAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(978)
		p.Type_()
	}
	{
		p.SetState(979)
		p.Match(GoParserR_PAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_PAREN() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	Type_() IType_Context
	ELLIPSIS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_arguments
	return p
}

func InitEmptyArgumentsContext(p *ArgumentsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_arguments
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserL_PAREN, 0)
}

func (s *ArgumentsContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(GoParserR_PAREN, 0)
}

func (s *ArgumentsContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArgumentsContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ArgumentsContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(GoParserELLIPSIS, 0)
}

func (s *ArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GoParserCOMMA)
}

func (s *ArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GoParserCOMMA, i)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, GoParserRULE_arguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(981)
		p.Match(GoParserL_PAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(996)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -1152921485346599400) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 396543) != 0) {
		p.SetState(988)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(982)
				p.ExpressionList()
			}


		case 2:
			{
				p.SetState(983)
				p.Type_()
			}
			p.SetState(986)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(984)
					p.Match(GoParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(985)
					p.ExpressionList()
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(991)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoParserELLIPSIS {
			{
				p.SetState(990)
				p.Match(GoParserELLIPSIS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == GoParserCOMMA {
			{
				p.SetState(993)
				p.Match(GoParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}

	}
	{
		p.SetState(998)
		p.Match(GoParserR_PAREN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMethodExprContext is an interface to support dynamic dispatch.
type IMethodExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context
	DOT() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsMethodExprContext differentiates from other interfaces.
	IsMethodExprContext()
}

type MethodExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodExprContext() *MethodExprContext {
	var p = new(MethodExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_methodExpr
	return p
}

func InitEmptyMethodExprContext(p *MethodExprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_methodExpr
}

func (*MethodExprContext) IsMethodExprContext() {}

func NewMethodExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodExprContext {
	var p = new(MethodExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_methodExpr

	return p
}

func (s *MethodExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodExprContext) Type_() IType_Context {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *MethodExprContext) DOT() antlr.TerminalNode {
	return s.GetToken(GoParserDOT, 0)
}

func (s *MethodExprContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoParserIDENTIFIER, 0)
}

func (s *MethodExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MethodExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterMethodExpr(s)
	}
}

func (s *MethodExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitMethodExpr(s)
	}
}

func (s *MethodExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitMethodExpr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) MethodExpr() (localctx IMethodExprContext) {
	localctx = NewMethodExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, GoParserRULE_methodExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1000)
		p.Type_()
	}
	{
		p.SetState(1001)
		p.Match(GoParserDOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1002)
		p.Match(GoParserIDENTIFIER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEosContext is an interface to support dynamic dispatch.
type IEosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	EOF() antlr.TerminalNode
	EOS() antlr.TerminalNode

	// IsEosContext differentiates from other interfaces.
	IsEosContext()
}

type EosContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEosContext() *EosContext {
	var p = new(EosContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_eos
	return p
}

func InitEmptyEosContext(p *EosContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoParserRULE_eos
}

func (*EosContext) IsEosContext() {}

func NewEosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EosContext {
	var p = new(EosContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoParserRULE_eos

	return p
}

func (s *EosContext) GetParser() antlr.Parser { return s.parser }

func (s *EosContext) SEMI() antlr.TerminalNode {
	return s.GetToken(GoParserSEMI, 0)
}

func (s *EosContext) EOF() antlr.TerminalNode {
	return s.GetToken(GoParserEOF, 0)
}

func (s *EosContext) EOS() antlr.TerminalNode {
	return s.GetToken(GoParserEOS, 0)
}

func (s *EosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EosContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.EnterEos(s)
	}
}

func (s *EosContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoParserListener); ok {
		listenerT.ExitEos(s)
	}
}

func (s *EosContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GoParserVisitor:
		return t.VisitEos(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *GoParser) Eos() (localctx IEosContext) {
	localctx = NewEosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, GoParserRULE_eos)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1004)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoParserEOF || _la == GoParserSEMI || _la == GoParserEOS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


func (p *GoParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 76:
			var t *ExpressionContext = nil
			if localctx != nil { t = localctx.(*ExpressionContext) }
			return p.Expression_Sempred(t, predIndex)

	case 77:
			var t *PrimaryExprContext = nil
			if localctx != nil { t = localctx.(*PrimaryExprContext) }
			return p.PrimaryExpr_Sempred(t, predIndex)


	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *GoParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
			return p.Precpred(p.GetParserRuleContext(), 5)

	case 1:
			return p.Precpred(p.GetParserRuleContext(), 4)

	case 2:
			return p.Precpred(p.GetParserRuleContext(), 3)

	case 3:
			return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GoParser) PrimaryExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

